// these might need to be contracts
struct LoanOffer {
    contract: Address, 
    lender: Address,
    token: ByteVec,
    amount: U256,
    minInterestRate: U256,
    duration: U256
}

struct LoanRequest {
    contract: Address,   
    borrower: Address,
    token: ByteVec,
    amount: U256,
    maxInterestRate: U256,
    duration: U256
}

struct ActiveLoan {
    contract: Address,
    lender: Address,
    borrower: Address,
    token: ByteVec,
    amount: U256,
    interestRate: U256,
    duration: U256
}

Contract OrderBook (
	admin: Address,
	feeTemplate: ByteVec,
	orderTemplate: ByteVec,
	fee: U256,
	oracle: ByteVec,
	alpaca: ByteVec
) {
    // token | contracts
    //! possible use subContracts and encodeToByteVec!() for further effciency
    mapping [ByteVec, ByteVec] loanOfferIds
    mapping [ByteVec, ByteVec] loanRequestIds

    // id | struct
    mapping [ByteVec, LoanOffer] loanOffers
    mapping [ByteVec, LoanRequest] loanRequests
    mapping [ByteVec, ActiveLoan] activeLoans

    // error codes
    enum LendingPoolFactoryCodes {
        InvalidCaller = 0
    }

    // array manipulation
    // ---------------------------------------------------------
    pub fn get(array: ByteVec, index: U256) -> U256 {
        assert!(size!(array) % 4 == 0, 0)

        let offset = index * 4
        let bytes = byteVecSlice!(array, offset, offset + 4)
        return u256From4Byte!(bytes)
    }

    // Avoid this function because it costs more gas and creates new ByteVec.
    pub fn update(array: ByteVec, index: U256, value: U256) -> ByteVec {
        assert!(size!(array) % 4 == 0, 0)

        let offset = index * 4
        return byteVecSlice!(array, 0, offset) ++ u256To4Byte!(value) ++ byteVecSlice!(array, offset + 4, size!(array))
    }

    pub fn push(array: ByteVec, value: U256) -> ByteVec {
        assert!(size!(array) % 4 == 0, 0)

        return array ++ u256To4Byte!(value)
    }

    pub fn pop(array: ByteVec) -> (ByteVec, U256) {
        assert!(size!(array) % 4 == 0, 0)

        let offset = size!(array) - 4
        let value = u256From4Byte!(byteVecSlice!(array, offset, offset + 4))
        return byteVecSlice!(array, 0, offset), value
    }

    // * remove at specific index
    pub fn remove(array: ByteVec, index: U256) -> (ByteVec, U256) {
        assert!(size!(array) % 4 == 0, 0)
        let offset = index * 4
        let value = u256From4Byte!(byteVecSlice!(array, offset, offset + 4))
        return byteVecSlice!(array, 0, offset) ++ byteVecSlice!(array, offset + 4, size!(array)), value
    }
    // ---------------------------------------------------------

    // collateral ratios //! double check these
	fn determineCollateralRatio(
        tokenRequested: ByteVec,
        tokenAmount: U256,
        tokenOracle: Bool,
        collateralToken: ByteVec, 
        collateralAmount: U256,
        collateralOracle: Bool,
        threshhold: U256
    ) -> (U256, Bool) {
        if (tokens.contains!(tokenRequested) == true && tokens.contains!(collateralToken)) {
            let mut loanValue = 0
            let mut collateralValue = 0

            // fetch token price
            if (tokenOracle) {
                loanValue = TestOracle(oracle).getValue(tokens[tokenRequested].pair).value
            }
            else {
                loanValue = AlpacaFiOracle(alpaca).getValue(tokens[tokenRequested].pair).value
            }

            // fetch collateral price
            if (collateralOracle) {
                collateralValue = TestOracle(oracle).getValue(tokens[collateralToken].pair).value
            }
            else {
                collateralValue = AlpacaFiOracle(alpaca).getValue(tokens[collateralToken].pair).value
            }

            if (loanValue == 0 || collateralValue == 0) {
                return 0, false
            }

            let collateralDecimals = tokens[collateralToken].decimals
            let tokenDecimals = tokens[tokenRequested].decimals

            // Normalize collateral amount to 18 decimals
            let collateralNormalized = (collateralAmount * (10 |**| 18)) / (10 |**| collateralDecimals)
            let collateralValueUSD = (collateralNormalized * collateralValue) / (10 |**| 8) // Remove 8 decimals

            // Normalize loan amount to 18 decimals
            let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| tokenDecimals)
            let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8) // Remove 8 decimals

            // Compute collateral-to-loan ratio in basis points (10000 = 100%)
            let ratio = (collateralValueUSD * 10000) / loanValueUSD // Multiply before division to avoid precision loss

            if (ratio > threshhold) {
                return ratio, true
            }

            else {
                return ratio, false
            }
        }

        return 0, false
    }
	
	@using(checkExternalCaller = false) 
    pub fn determineCollateralAmount(
        tokenPair: ByteVec,
        tokenDecimals: U256,
        tokenAmount: U256,
        desiredRatio: U256
    ) -> (U256) {
        let loanValue = AlpacaFiOracle(alpaca).getValue(tokenPair).value
        let collateralValue = AlpacaFiOracle(alpaca).getValue(tokenPair).value

        if (loanValue == 0 || collateralValue == 0 || desiredRatio == 0) {
            return 0
        }

        let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| tokenDecimals)
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8)

        let requiredCollateralUSD = (loanValueUSD * desiredRatio) / 10000

        let collateralNormalized = (requiredCollateralUSD * (10 |**| 8)) / collateralValue
        let requiredCollateralAmount = (collateralNormalized * (10 |**| tokenDecimals)) / (10 |**| 18)

        return requiredCollateralAmount
    }
    //! ----------------------------------------

    // matching algorithm -> this needs work
    pub fn matchLoans(request: Bool, token: ByteVec, amount: U256, rate: U256) -> () {
        // if the order is to take a loan
        if (request) {
            //* fetch available loan offers for this token
            let offerList = loanOfferIds[token]
            let len = size!(offerList) / 4
            
            // loop over options
            for (let mut i = 0; i < len; i = i + 1) {

                //* data struct variables and declaration
                let offerId = get(offerList, i)
                let offer = loanOffers[offerId] // fetch the offer
    
                if (offer.active && offer.amount >= amount && offer.rate <= rate) {
                    // convert offer into active loan for fulfillment
                    let (encodeImmutableFields, encodeMutableFields) = ActiveLoanTemplate.encodeFields!(
                        selfAddress!(),
                        // get lender -> Offer Contract
                        callerAddress!(),
                        offer.amount,
                        // determine collateral needed
                        offer.minInterestRate,
                        blockTimeStamp!()
                    )

                    activeLoans[@caller] = ActiveLoan(@caller, offer.lender, token, amount, offer.rate)
    
                    // Update or remove offer
                    if (offer.amount > amount) {
                        loanOffers[offerId].amount -= amount
                    } else {
                        delete loanOffers[offerId]
                        loanOfferIds[token] = removeByIndex(loanOfferIds[token], i)  // Remove matched offer
                    }
                    return
                }
            }
    
            // No match found, create a new loan request
            let orderId = createLoanRequest(token, amount, rate)
            loanRequestIds[token] = push(loanRequestIds[token], orderId)
        } 
        else {
            // Fetch available loan requests for this token
            let requestList = loanRequestIds[token]
            let len = size!(requestList) / 4
    
            for i in 0..len {
                let requestId = get(requestList, i)
                let req = loanRequests[requestId]
    
                if (req.active && req.amount <= amount && req.rate >= rate) {
                    // Fulfill loan
                    activeLoans[req.borrower] = ActiveLoan(req.borrower, @caller, token, req.amount, rate)
    
                    // Update or remove request
                    if (req.amount < amount) {
                        loanRequests[requestId].amount -= amount
                    } else {
                        delete loanRequests[requestId]
                        loanRequestIds[token] = removeByIndex(loanRequestIds[token], i)  // Remove matched request
                    }
                    return
                }
            }
    
            // No match found, create a new loan offer
            let orderId = createLoanOffer(token, amount, rate)
            loanOfferIds[token] = push(loanOfferIds[token], orderId)
        }
    }
}
