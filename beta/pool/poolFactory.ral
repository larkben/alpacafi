Contract PoolFactory () {
    admin: Address,
    poolTemplate: ByteVec,
    alpacaPoolTemplate: ByteVec,
    comissionRate: U256
} {
    event Deposit (
        who: Address,
        pair: ByteVec,
        token: ByteVec,
        amount: U256
    )
    event Withdraw (
        who: Address,
        pair: ByteVec,
        token: ByteVec,
        amount: U256
    )
    event CollateralAdded (
        who: Address,
        pair: ByteVec,
        collateral: ByteVec,
        amount: U256
    )
    event Borrow (
        who: Caller, 
        pair: ByteVec,
        path: ByteVec,
        token: ByteVec, 
        amount: U256
    )
    event Repay (
        who: Caller,
        pair: ByteVec,
        path: ByteVec,
        token: ByteVec,
        amount: U256
    )
    event Liquidate (
        who: Caller,
        pair: ByteVec,
        path: ByteVec,
        collateral: ByteVec,
        amount: U256
    )

    // create pool


    // deposit
    @using(checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true, updateFields = true)
    pub fn deposit(pair: ByteVec, amount: U256) -> () {
        let pool = Pool(subContractId!(pair))

        let caller = callerAddress!()

        let (token, _) = pool.getPoolTokens()

        pool.deposit{caller -> token: amount}(caller, amount)

        // sTokens recieved
        emit Deposit(
            caller, 
            pair, 
            token, 
            amount
        )
    }

    // withdraw
    @using(checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true, updateFields = true)
    pub fn withdraw(amount: U256) -> () {
        let pool = Pool(subContractId!(pair))

        let caller = callerAddress!()

        let (token, _) = pool.getPoolTokens()

        pool.withdraw(caller, amount)

        // token recieved
        emit Withdraw(
            caller, 
            pair, 
            token, 
            amount
        )
    }

    // Provide collateral to borrow against -> collateral account
    @using(checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true, updateFields = false)
    pub fn depositCollateral(pair: ByteVec, amount: U256) -> () {
        let pool = Pool(subContractId!(pair))

        let caller = callerAddress!()

        let (_, collateral) = pool.getPoolTokens()

        pool.depositCollateral{caller -> collateral: amount}(caller, amount)

        emit CollateralAdded(
            caller, 
            pair, 
            collateral, 
            amount
        )
    }

    // borrow -> borrow (create loan + mapping)
    @using(checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true, updateFields = true)
    pub fn borrow(pair: ByteVec, amount: U256) -> () {
        let pool = Pool(subContractId!(pair))

        let caller = callerAddress!()
        let time = blockTimeStamp!()

        // get token
        let (token, _) = pool.getPoolTokens()

        pool.borrow(caller, amount, amount, encodeToByteVec!(caller, time))

        emit Borrow(
            caller,
            pair,
            token,
            amount,
            encodeToByteVec!(caller, time)
        )
    }

    // repay
    @using(checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true, updateFields = true)
    pub fn repay(pair: ByteVec, path: ByteVec, amount: U256) -> () {
        let pool = Pool(subContractId!(pair))

        let caller = callerAddress!()

        let (token, _) = pool.getPoolTokens()

        // calculate repayment

        pool.repay{caller -> token: amount}(amount)

        emit Repay (
            caller,
            pair,
            path,
            token,
            amount
        )
    }

    @using(checkExternalCaller = false, preapprovedAssets = false, assetsInContract = true, updateFields = true)
    pub fn liquidate(borrower: Address) -> () {
        let pool = Pool(subContractId!(pair))

        let caller = callerAddress!()

        // get token

        pool.liquidate{caller -> token: amount}(amount)

        emit Liquidate (

        )
    }
}