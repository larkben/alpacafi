Contract Pool (
    admin: Address,
    poolToken: ByteVec,
    poolDecimals: U256,
    poolPair: ByteVec,
    // collateral
    collateralToken: ByteVec,
    collateralDecimals: U256,
    collateralPair: U256,
    // specs
    mut totalDeposits: U256,
    mut totalBorrowed: U256,
    mut interestRate: U256,
    mut liquidationThreshold: U256, // 12500
    mut collateralFactor: U256,     // 15000
    // oracle
    oracle: IDIAOracle
) {
    // mapping
    mapping [Address, U256] loans
    mapping [Address, U256] deposits
    mapping [Address, U256] collateral

    // events
    event Deposited(who: Address, amount: U256)
    event Borrowed(who: Address, amount: U256, collateralAmount: U256)
    event Repaid(who: Address, amount: U256)
    event Liquidated(who: Address, liquidator: Address)

    enum PoolCodes {
        CannotDepositZero = 0
        CannotBorrowZero = 1
        InsuffcientLiquidity = 2
        InsuffcientCollateral = 3
        NoActiveLoan = 4
    }

    pub fn returnBen() -> ByteVec {
        return #ben
    }

    fn determineCollateralRatio(
        tokenAmount: U256,
        collateralAmount: U256,
        threshhold: U256
    ) -> (U256) {
        // fetch token price
        loanValue = oracle.getValue(poolPair).value
        collateralValue = oracle.getValue(collateralPair).value

        if (loanValue == 0 || collateralValue == 0) {
            return 0, false
        }

        let collateralNormalized = (collateralAmount * (10 |**| 18)) / (10 |**| collateralDecimals)
        let collateralValueUSD = (collateralNormalized * collateralValue) / (10 |**| 8) // Remove 8 decimals

        let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| poolDecimals)
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8) // Remove 8 decimals

        let ratio = (collateralValueUSD * 10000) / loanValueUSD // Multiply before division to avoid precision loss

        return ratio
    }

    fn getPoolBalance() -> (U256) {
        let caller = callerAddress!()

        assert!(deposits.contains!(caller))

        return deposits[caller]
    }

    // deposit
    pub fn deposit(amount: U256) -> () {
        assert!(amount > 0, PoolCodes.CannotDepositZero);

        let caller = callerAddress!()

        transferToken!(caller, selfAddress!(), poolToken, amount);

        if (deposits.contains!(caller)) {
            deposits.insert!(caller, caller, amount)
        }
        else {
            deposits[caller] = deposits[caller] + amount
        }

        totalDeposits += amount

        emit Deposited(call, amount);
    }

    // ðŸ“Œ Provide collateral to borrow against
    pub fn depositCollateral(amount: U256) {
        assert!(amount > 0, PoolCodes.CannotDepositZero)

        let caller = callerAddress!()

        transferToken!(caller, selfAddress!(), collateralToken, amount)

        if (collateral.contains!(address)) {
            collateral[caller] = collateral[caller] + amount
        }
        else {
            collateral.insert!(caller, caller, amount)
        }
    }

    // borrow
    pub fn borrow(amount: U256) -> () {
        assert!(amount > 0, PoolCodes.CannotBorrowZero)
        assert!(totalDeposits - totalBorrowed >= amount, PoolCodes.InsuffcientLiquidity)

        let caller = callerAddress!()

        // Calculate required collateral (e.g., 150% of loan amount)
        let collateralRatio = determineCollateralRatio(amount, collateral[caller], collateralFactor)

        assert!(collateralRatio >= collateralFactor, PoolCodes.InsuffcientCollateral)

        let interest = (amount * interestRate) / 10000 // Calculate interest

        if (loans.contains!(caller)) {
            loans[caller] = loans[caller] + (amount + interest)
        }
        else {
            loans.insert!(caller, caller, amount + interest)
        }

        totalBorrowed = totalBorrowed + (amount + interest)

        transferToken!(selfAddress!(), caller, poolToken, amount)

        emit Borrowed(caller, amount, collateralRatio)
    }

    // repay
    pub fn repay(amount: U256) -> () {
        let caller = callerAddress!()

        // confirm caller has loans
        assert!(loans.contains!(caller) == 0, PoolCodes.NoActiveLoan)

        transferToken!(caller, selfAddress!(), poolToken, amount);
        loans[caller] = loans[caller] - amount;

        emit Repaid(caller, amount);
    }

    // liquidate
    pub fn liquidate()

    // getPoolBalanceBalance
    pub fn getPoolBalance() -> () {
        let caller = callerAddress!()

        assert!(despoits)
    }
}