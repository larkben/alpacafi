import "std/fungible_token_interface"

// Formulas
// STokens = DepositedAmount / ExchnageRate
// ExchnageRate(new) = TotalPoolAssets / TotalSTokens
// AssetsRecieved = sTokens * ExchangeRate

// ALPH : ALPH Pool Loans

Contract Pool (
    admin: Address,
    poolToken: ByteVec,
    poolDecimals: U256,
    poolPair: ByteVec,
    // sPoolToken and Pool values
    name: ByteVec,
    symbol: ByteVec,
    mut sTokenSupply: U256,
    mut exchangeRate: U256,
    mut totalPoolAssets: U256,
    mut depositedAmount: U256,
    // pool specs
    oracle: IDIAOracle
) implements IFungibleToken {

    enum PoolCodes {
        CannotDepositZero = 0,
        CannotBorrowZero = 1,
        InsufficientLiquidity = 2,
        InsufficientCollateral = 3,
        NoActiveLoan = 4,
        NoOverPayment = 5
    }

    pub fn getSymbol() -> (ByteVec) {
        return symbol
    }

    pub fn getName() -> (ByteVec) {
        return name
    }

    pub fn getDecimals() -> (U256) {
        return 18
    }

    pub fn getTotalSupply() -> (U256) {
        return // stupid large number
    }

    fn calculateAccruedInterest(loanInfo: LoanInfo) -> (U256) {
        let timeElapsed = blockTimeStamp!() - loanInfo.lastInterestUpdate
        // Interest = principal * rate * time / (seconds per year * 10000)
        let secondsPerYear = 31536000
        return (loanInfo.principal * interestRate * timeElapsed) / (secondsPerYear * 10000)
    }

    fn determineCollateralRatio(
        tokenAmount: U256,
        collateralAmount: U256,
        threshhold: U256
    ) -> (U256) {
        // fetch token price
        let loanValue = oracle.getValue(poolPair).value
        let collateralValue = oracle.getValue(poolPair).value

        if (loanValue == 0 || collateralValue == 0) {
            return 0
        }

        let collateralNormalized = (collateralAmount * (10 |**| 18)) / (10 |**| poolDecimals)
        let collateralValueUSD = (collateralNormalized * collateralValue) / (10 |**| 8) // Remove 8 decimals

        let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| poolDecimals)
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8) // Remove 8 decimals

        let ratio = (collateralValueUSD * 10000) / loanValueUSD // Multiply before division to avoid precision loss

        return ratio
    }

    @using(checkExternalCaller = false) 
    pub fn determineCollateralAmount(
        tokenAmount: U256,
        desiredRatio: U256
    ) -> (U256) {
        let loanValue = oracle.getValue(poolPair).value
        let collateralValue = oracle.getValue(poolPair).value

        if (loanValue == 0 || collateralValue == 0 || desiredRatio == 0) {
            return 0
        }

        let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| poolDecimals)
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8)

        let requiredCollateralUSD = (loanValueUSD * desiredRatio) / 10000

        let collateralNormalized = (requiredCollateralUSD * (10 |**| 8)) / collateralValue
        let requiredCollateralAmount = (collateralNormalized * (10 |**| poolDecimals)) / (10 |**| 18)

        return requiredCollateralAmount
    }

	@using
    pub fn deposit(amount: U256) -> () {
        let caller = callerAddress!()

		transferToken!(caller, selfAddress!(), ALPH, dustAmount!() * 3)
		transferToken!(caller, selfAddress!(), poolToken, amount)

		let totalSTokens = amount / exchangeRate
		
		sTokenSupply = sTokenSupply + totalSTokens

		transferToken!(selfAddress!(), caller, ALPH, dustAmount!())
		transferToken!(selfAddress!(), caller, selfContractId!(), totalSTokens)
		
		depositedAmount = depositedAmount + amount
		totalPoolAssets = totalPoolAssets + amount

		exchangeRate = totalPoolAssets / sTokenSupply
    }

	@using
    pub fn withdraw(amount: U256) -> () {
        let caller = callerAddress!()
        
	    transferToken!(caller, selfAddress!(), ALPH, dustAmount!() * 3)
		transferToken!(caller, selfAddress!(), selfContractId!(), amount)

		// perform math
    }

	@using()
    pub fn borrow(amount: U256) -> () {
        // .. code

		// establish collateral needed with formula + token amount desired

		// approve collateral
    }

	@using()
    pub fn liquidate() -> () {
        // .. code
    }

}
