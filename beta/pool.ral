import "std/fungible_token_interface"

// Structs
struct LoanInfo {
    principal: U256,          // Outstanding principal
    collateralLocked: U256,   // Collateral locked for this loan
    borrower: Address,        // Borrower address
    lastInterestUpdate: U256  // Timestamp of last interest update
}

struct CollateralInfo {
    totalCollateral: U256,    // Total collateral deposited
    usedCollateral: U256      // Collateral locked for loans
}

struct BadDebtCollateral {
    amount: U256,
    liquidator: Address
}

Contract Pool (
    admin: Address,
    poolToken: ByteVec,
    poolDecimals: U256,
    poolPair: ByteVec,
    collateralToken: ByteVec,
    collateralDecimals: U256,
    collateralPair: ByteVec,
    // sPoolToken
    symbol: ByteVec,
    name: ByteVec,
    // pool specs
    totalDeposits: U256,
    totalBorrowed: U256,
    sPoolSupply: U256,
    exchangeRate: U256,         // 1000000000000000000 // 1e18, initial 1:1 ratio
    interestRate: U256,         // 200 // 2% annual in basis points (100 = 1%)
    baseRate: U256,             // 100 // 1% base rate
    slope: U256,                // 400 // Interest rate slope factor
    collateralFactor: U256,     // 15000 // 150% collateral ratio in basis points
    oracle: IDIAOracle
) implements IFungibleToken {
    
    // Mappings
    // Loans: (Address, ByteVec) -> LoanInfo for multiple loans per user
    mapping [Address, LoanInfo] loans
    // Collateral: Address -> CollateralInfo
    mapping [Address, CollateralInfo] collateral
    // BadDebtCollateral: For liquidation tracking (not implemented here)
    mapping [ByteVec, BadDebtCollateral] badDebtCollateral

    // Error codes
    enum PoolCodes {
        CannotDepositZero = 0,
        CannotBorrowZero = 1,
        InsufficientLiquidity = 2,
        InsufficientCollateral = 3,
        NoActiveLoan = 4,
        NoOverPayment = 5
    }

    // IFungibleToken implementation for sPoolToken
    pub fn getSymbol() -> (ByteVec) {
        return symbol
    }

    pub fn getName() -> (ByteVec) {
        return name
    }

    pub fn getDecimals() -> (U256) {
        return 18
    }

    pub fn getTotalSupply() -> (U256) {
        return sPoolSupply
    }

    fn min(a: U256, b: U256) -> (U256) {
        if (a < b) { return a }
        return b
    }

    fn utilizationRate() -> (U256) {
        if (totalDeposits == 0) { 
            return 0 
        }
        return (totalBorrowed * 10000) / totalDeposits // In basis points
    }

    @using(updateFields = true)
    fn updateInterestRate() -> () {
        let util = utilizationRate()
        // Linear model: interestRate = baseRate + (util * slope) / 10000
        interestRate = baseRate + (util * slope) / 10000
    }

    @using(updateFields = true)
    fn updateExchangeRate() -> () {
        let totalPoolToken = tokenBalance!(poolToken)
        if (sPoolSupply == 0) {
            exchangeRate = 1000000000000000000 // 1e18
        } else {
            exchangeRate = (totalPoolToken) / sPoolSupply
        }
    }

    fn calculateAccruedInterest(loanInfo: LoanInfo) -> (U256) {
        let timeElapsed = blockTimeStamp!() - loanInfo.lastInterestUpdate
        // Interest = principal * rate * time / (seconds per year * 10000)
        let secondsPerYear = 31536000
        return (loanInfo.principal * interestRate * timeElapsed) / (secondsPerYear * 10000)
    }

    fn determineCollateralRatio(
        tokenAmount: U256,
        collateralAmount: U256,
        threshhold: U256
    ) -> (U256) {
        // fetch token price
        let loanValue = oracle.getValue(poolPair).value
        let collateralValue = oracle.getValue(collateralPair).value

        if (loanValue == 0 || collateralValue == 0) {
            return 0
        }

        let collateralNormalized = (collateralAmount * (10 |**| 18)) / (10 |**| collateralDecimals)
        let collateralValueUSD = (collateralNormalized * collateralValue) / (10 |**| 8) // Remove 8 decimals

        let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| poolDecimals)
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8) // Remove 8 decimals

        let ratio = (collateralValueUSD * 10000) / loanValueUSD // Multiply before division to avoid precision loss

        return ratio
    }

    @using(checkExternalCaller = false) 
    pub fn determineCollateralAmount(
        tokenAmount: U256,
        desiredRatio: U256
    ) -> (U256) {
        let loanValue = oracle.getValue(poolPair).value
        let collateralValue = oracle.getValue(collateralPair).value

        if (loanValue == 0 || collateralValue == 0 || desiredRatio == 0) {
            return 0
        }

        let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| poolDecimals)
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8)

        let requiredCollateralUSD = (loanValueUSD * desiredRatio) / 10000

        let collateralNormalized = (requiredCollateralUSD * (10 |**| 8)) / collateralValue
        let requiredCollateralAmount = (collateralNormalized * (10 |**| collateralDecimals)) / (10 |**| 18)

        return requiredCollateralAmount
    }

    pub fn deposit() -> () {
        // .. code
    }

    pub fn withdraw() -> () {
        // .. code
    }

    pub fn borrow() -> () {
        // .. code
    }

    pub fn liquidate() -> () {
        // .. code
    }

}
