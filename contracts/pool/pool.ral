import "std/fungible_token_interface"

struct CollateralInfo {
    mut collateral: U256,
    mut usedCollateral: U256
}

struct LoanInfo {
    loanAmount: U256,
    borrower: Address
}

Contract Pool (
    poolToken: ByteVec,
    poolDecimals: U256,
    poolPair: ByteVec,
    // collateral
    collateralToken: ByteVec,
    collateralDecimals: U256,
    collateralPair: ByteVec,
    // pool ratio info
    mut exchangeRate: U256,
    mut sPoolSupply: U256,
    mut totalDeposits: U256,
    mut totalBorrowed: U256,
    collateralFactor: U256,
    mut interestRate: U256, // Make interest rate mutable
    // oracle
    oracle: IDIAOracle
) implements IFungibleToken {
    // mapping
    mapping [ByteVec, LoanInfo] loans
    mapping [Address, CollateralInfo] collateral

    // events
    event Deposited(who: Address, amount: U256)
    event Withdrawn(who: Address, amount: U256)
    event Borrowed(who: Address, amount: U256, collateralAmount: U256)
    event Repaid(who: Address, amount: U256)
    event Liquidated(who: Address, liquidator: Address)

    enum PoolCodes {
        CannotDepositZero = 0
        CannotBorrowZero = 1
        InsuffcientLiquidity = 2
        InsuffcientCollateral = 3
        NoActiveLoan = 4
    }

    pub fn getSymbol() -> (ByteVec) {
        return b``
    }

    pub fn getName() -> (ByteVec) {
        return b``
    }

    pub fn getDecimals() -> (U256) {
        return 18
    }

    pub fn getTotalSupply() -> (U256) {
        return 100000000000000000000000000000 // 100 billion sPoolTokens
    }

    pub fn getPoolTokens() -> (ByteVec, ByteVec) {
        return poolToken, collateralToken
    }

    pub fn getPairSToken() -> (ByteVec) {
        return selfContractId!()
    }

    @using(updateFields = true)
    fn updateExchangeRate() -> () {
        if (sPoolSupply > 0) {
            exchangeRate = (totalDeposits + totalBorrowed) / sPoolSupply
        }
    }
    
    @using(updateFields = true) 
    fn updateInterestRate() -> () {
        let mut utilization = 0
        if (totalDeposits == 0) {
            utilization = 0
        }
        else {
            utilization = (totalBorrowed * 10000) / totalDeposits
        }
    
        if (utilization < 5000) { // < 50%
            interestRate = 200 // 2%
        } else if (utilization < 8000) { // 50% - 80%
            interestRate = 500 // 5%
        } else if (utilization < 9000) { // 80% - 90%
            interestRate = 800 // 8%
        } else {
            interestRate = 1500 // 15% (High-risk)
        }
    }

    //fn updateInterestRate() -> () {
    //    let utilization = (totalBorrowed * 10000) / totalDeposits // Utilization in basis points
    //    if (utilization < 5000) { // < 50%
    //        interestRate = 200 // 2% interest
    //    } else if (utilization < 8000) { // < 80%
    //        interestRate = 500 // 5% interest
    //    } else {
    //        interestRate = 1000 // 10% interest
    //    }
    //}

    fn determineCollateralRatio(
        tokenAmount: U256,
        collateralAmount: U256,
        threshhold: U256
    ) -> (U256) {
        // fetch token price
        let loanValue = oracle.getValue(poolPair).value
        let collateralValue = oracle.getValue(collateralPair).value

        if (loanValue == 0 || collateralValue == 0) {
            return 0
        }

        let collateralNormalized = (collateralAmount * (10 |**| 18)) / (10 |**| collateralDecimals)
        let collateralValueUSD = (collateralNormalized * collateralValue) / (10 |**| 8) // Remove 8 decimals

        let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| poolDecimals)
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8) // Remove 8 decimals

        let ratio = (collateralValueUSD * 10000) / loanValueUSD // Multiply before division to avoid precision loss

        return ratio
    }

    @using(checkExternalCaller = false) 
    pub fn determineCollateralAmount(
        tokenAmount: U256,
        desiredRatio: U256
    ) -> (U256) {
        let loanValue = oracle.getValue(poolPair).value
        let collateralValue = oracle.getValue(collateralPair).value

        if (loanValue == 0 || collateralValue == 0 || desiredRatio == 0) {
            return 0
        }

        let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| poolDecimals)
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8)

        let requiredCollateralUSD = (loanValueUSD * desiredRatio) / 10000

        let collateralNormalized = (requiredCollateralUSD * (10 |**| 8)) / collateralValue
        let requiredCollateralAmount = (collateralNormalized * (10 |**| collateralDecimals)) / (10 |**| 18)

        return requiredCollateralAmount
    }

    // deposit
    @using(checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true, updateFields = true)
    pub fn deposit(amount: U256) -> () {
        assert!(amount > 0, PoolCodes.CannotDepositZero)

        let caller = callerAddress!()
        transferToken!(caller, selfAddress!(), poolToken, amount)

        let mintedShares = amount / exchangeRate
        sPoolSupply = sPoolSupply + mintedShares
        totalDeposits = totalDeposits + amount

        transferToken!(selfAddress!(), caller, selfContractId!(), mintedShares)

        updateInterestRate()
        updateExchangeRate()
        emit Deposited(caller, amount)
    }

    // withdraw
    @using(checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true, updateFields = true)
    pub fn withdraw(sPoolAmount: U256) -> () {
        assert!(sPoolAmount > 0, PoolCodes.CannotDepositZero)

        let caller = callerAddress!()
        let withdrawAmount = (sPoolAmount * exchangeRate)
        assert!(totalDeposits >= withdrawAmount, PoolCodes.InsuffcientLiquidity)
    
        sPoolSupply = sPoolSupply - sPoolAmount
        totalDeposits = totalDeposits - withdrawAmount
    
        transferToken!(caller, selfAddress!(), selfContractId!(), sPoolAmount)
        transferToken!(selfAddress!(), caller, poolToken, withdrawAmount)
    
        updateInterestRate()
        updateExchangeRate()
        emit Withdrawn(caller, withdrawAmount)
    }

    // Provide collateral
    @using(checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true, updateFields = false)
    pub fn depositCollateral(amount: U256) -> () {
        assert!(amount > 0, PoolCodes.CannotDepositZero)

        let caller = callerAddress!()
        transferToken!(caller, selfAddress!(), collateralToken, amount)

        if (collateral.contains!(caller)) {
            collateral[caller].collateral = collateral[caller].collateral + amount
        } 
        else {
            let b = CollateralInfo {
                collateral: amount,
                usedCollateral: 0
            }
            collateral.insert!(caller, caller, b)
        }
    }

    // Borrow
    @using(checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true, updateFields = true)
    pub fn borrow(caller: Address, amount: U256, path: ByteVec) -> () {
        assert!(amount > 0, PoolCodes.CannotBorrowZero)
        assert!(totalDeposits - totalBorrowed >= amount, PoolCodes.InsuffcientLiquidity)

        let requiredCollateral = determineCollateralAmount(amount, collateralFactor)
        depositCollateral{caller -> collateralToken: requiredCollateral, ALPH: mapEntryDeposit!()}(requiredCollateral)

        let mut info = collateral[caller]
        info.usedCollateral = info.usedCollateral + requiredCollateral
        collateral[caller] = info

        let interest = (amount * interestRate) / 10000
        let b = LoanInfo {
            loanAmount: amount + interest,
            borrower: caller
        }

        loans.insert!(caller, path, b)

        totalBorrowed = totalBorrowed + (amount + interest)
        transferToken!(selfAddress!(), caller, poolToken, amount)

        updateInterestRate()
        updateExchangeRate()
        emit Borrowed(caller, amount, requiredCollateral)
    }

    @using(checkExternalCaller = false, preapprovedAssets = false, assetsInContract = true, updateFields = true)
    pub fn liquidate(caller: Address, path: ByteVec) -> () {
        // Ensure the specified debt exists
        assert!(loans.contains!(path), PoolCodes.NoActiveLoan)

        let loanInfo = loans[path]
        let borrower = loanInfo.borrower
        let loanAmount = loanInfo.loanAmount

        // Ensure borrower has sufficient collateral mapping
        assert!(collateral.contains!(borrower), PoolCodes.InsuffcientCollateral)
        let mut collateralInfo = collateral[borrower]

        // Calculate current collateral ratio
        let collateralRatio = determineCollateralRatio(loanAmount, collateralInfo.collateral, collateralFactor)
        assert!(collateralRatio < collateralFactor, PoolCodes.InsuffcientCollateral)

        // Determine the required collateral for liquidation (150% of the loan amount)
        let requiredCollateral = determineCollateralAmount(loanAmount, 15000)

        // Determine the liquidation penalty (10% of collateral)
        let liquidationPenalty = (collateralInfo.collateral * 10) / 100

        // If the borrower has less than required, take only what's available
        let mut liquidationAmount = 0
        if (collateralInfo.collateral < requiredCollateral) {
            liquidationAmount = collateralInfo.collateral
        }
        else {
            liquidationAmount = requiredCollateral
        }

        // Transfer liquidation penalty to liquidator
        transferToken!(selfAddress!(), caller, collateralToken, liquidationPenalty)

        // Reduce borrower's collateral balance
        collateralInfo.collateral = collateralInfo.collateral - liquidationAmount

        // If no more collateral left, remove borrower from mapping
        if (collateralInfo.collateral == 0) {
            collateral.remove!(caller, borrower)
        } else {
            collateral[borrower] = collateralInfo
        }

        // Remove only this specific debt entry
        loans.remove!(caller, path)

        // Reduce total borrowed amount
        totalBorrowed = totalBorrowed - loanAmount

        // Update interest rate based on remaining pool utilization
        updateInterestRate()

        emit Liquidated(borrower, caller)
    }

    @using(checkExternalCaller = false, preapprovedAssets = false, assetsInContract = true, updateFields = true)
    pub fn repay(path: ByteVec) -> () {
        assert!(loans.contains!(path), PoolCodes.NoActiveLoan)

        let loanInfo = loans[path]
        let borrower = loanInfo.borrower
        let repaymentAmount = loanInfo.loanAmount

        transferToken!(callerAddress!(), selfAddress!(), poolToken, repaymentAmount)

        // Remove the loan entry
        loans.remove!(callerAddress!(), path)

        totalBorrowed = totalBorrowed - repaymentAmount
        updateInterestRate()
        updateExchangeRate()
        emit Repaid(borrower, repaymentAmount)
    }
}
