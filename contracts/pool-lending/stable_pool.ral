import "std/fungible_token_interface"

// Formulas
// STokens = DepositedAmount / ExchnageRate
// ExchnageRate(new) = TotalPoolAssets / TotalSTokens
// AssetsRecieved = sTokens * ExchangeRate

// ALPH : ALPH Pool Loans

Contract Pool (
    admin: Address,
    debtTemplate: ByteVec,
    poolToken: ByteVec,
    poolDecimals: U256,
    poolPair: ByteVec,
    // sPoolToken and Pool values
    name: ByteVec,
    symbol: ByteVec,
    mut sTokenSupply: U256,
    mut exchangeRate: U256,
    mut totalPoolAssets: U256,
    mut depositedAmount: U256,
    mut totalBorrowed: U256,
    mut fees: U256,
    // pool specs
    oracle: IDIAOracle
) implements IFungibleToken {

    event NewDebt(who: Address, loan: U256, collateral: U256, rate: U256, contract: ByteVec)
    event RemoveDebt(who: Address, contract: ByteVec)

    enum PoolCodes {
        CannotDepositZero = 0
        CannotBorrowZero = 1
        InsufficientLiquidity = 2
        InsufficientCollateral = 3
        NoActiveLoan = 4
        NoOverPayment = 5
        WrongDebtPool = 6
        NotOwner = 7
    }

    pub fn getSymbol() -> (ByteVec) {
        return symbol
    }

    pub fn getName() -> (ByteVec) {
        return name
    }

    pub fn getDecimals() -> (U256) {
        return 18
    }

    pub fn getTotalSupply() -> (U256) {
        return 10000000000000000000000000000000000000000
    }

    pub fn getPoolToken() -> () {
        return poolToken
    }

    pub fn getSPoolToken() -> () {
        return selfTokenId!()
    }

    //fn calculateAccruedInterest(loanInfo: LoanInfo) -> (U256) {
    //    let timeElapsed = blockTimeStamp!() - loanInfo.lastInterestUpdate
    //    // Interest = principal * rate * time / (seconds per year * 10000)
    //    let secondsPerYear = 31536000
    //    return (loanInfo.principal * interestRate * timeElapsed) / (secondsPerYear * 10000)
    //}

    fn getPoolRate() -> (U256) {
        let utilization = (totalBorrowed * 10000) / totalPoolAssets
    
        if (utilization < 5000) { // < 50%
            return 200 // 2%
        } else if (utilization < 8000) { // 50% - 80%
            return 500 // 5%
        } else if (utilization < 9000) { // 80% - 90%
            return 800 // 8%
        } else {
            return 1500 // 15% (High-risk)
        }
    }

    fn determineCollateralRatio(
        tokenAmount: U256,
        collateralAmount: U256
    ) -> (U256) {
        // fetch token price
        let loanValue = oracle.getValue(poolPair).value
        let collateralValue = oracle.getValue(poolPair).value

        if (loanValue == 0 || collateralValue == 0) {
            return 0
        }

        let collateralNormalized = (collateralAmount * (10 |**| 18)) / (10 |**| poolDecimals)
        let collateralValueUSD = (collateralNormalized * collateralValue) / (10 |**| 8) // Remove 8 decimals

        let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| poolDecimals)
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8) // Remove 8 decimals

        let ratio = (collateralValueUSD * 10000) / loanValueUSD // Multiply before division to avoid precision loss

        return ratio
    }

    @using(checkExternalCaller = false) 
    pub fn determineCollateralAmount(
        tokenAmount: U256,
        desiredRatio: U256
    ) -> (U256) {
        let loanValue = oracle.getValue(poolPair).value
        let collateralValue = oracle.getValue(poolPair).value

        if (loanValue == 0 || collateralValue == 0 || desiredRatio == 0) {
            return 0
        }

        let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| poolDecimals)
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8)

        let requiredCollateralUSD = (loanValueUSD * desiredRatio) / 10000

        let collateralNormalized = (requiredCollateralUSD * (10 |**| 8)) / collateralValue
        let requiredCollateralAmount = (collateralNormalized * (10 |**| poolDecimals)) / (10 |**| 18)

        return requiredCollateralAmount
    }

    pub fn getTotalRepayment(contract: ByteVec) -> (U256) {
        let debt = Debt(subContractId!(contract))

        let totalDebt = debt.calculateRepayment()

        return totalDebt
    }

    @using(checkExternalCaller = false, updateFields = true)
    pub fn getPoolFee(amount: U256) -> (U256) {
        let flatFee = (amount * 3) / 100            // 3% fee on borrow

        fees = fees + flatFee

        return flatFee
    }

	@using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn deposit(amount: U256) -> () {
        let caller = callerAddress!()

        assert!(amount > 0, PoolCodes.CannotDepositZero)

        transferToken!(caller, selfAddress!(), ALPH, dustAmount!() * 3)
        transferToken!(caller, selfAddress!(), poolToken, amount)

        let totalSTokens = amount / exchangeRate
        sTokenSupply = sTokenSupply + totalSTokens

        transferToken!(selfAddress!(), caller, ALPH, dustAmount!())
        transferToken!(selfAddress!(), caller, selfContractId!(), totalSTokens)

        depositedAmount = depositedAmount + amount
        totalPoolAssets = totalPoolAssets + amount

        exchangeRate = totalPoolAssets / sTokenSupply
    }

    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn withdraw(amount: U256) -> () {
        let caller = callerAddress!()
        
        transferToken!(caller, selfAddress!(), ALPH, dustAmount!() * 3)
        transferToken!(caller, selfAddress!(), selfContractId!(), amount)

        let assetsToReceive = amount * exchangeRate
        assert!(depositedAmount >= assetsToReceive, PoolCodes.InsufficientLiquidity)

        sTokenSupply = sTokenSupply - amount
        totalPoolAssets = totalPoolAssets - assetsToReceive
        depositedAmount = depositedAmount - assetsToReceive

        transferToken!(selfAddress!(), caller, ALPH, dustAmount!() * 3)
        transferToken!(selfAddress!(), caller, poolToken, assetsToReceive)
    }

    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn borrow(amount: U256) -> () {
        let caller = callerAddress!()
        assert!(amount > 0, PoolCodes.CannotBorrowZero)
        assert!(totalPoolAssets - totalBorrowed >= amount, PoolCodes.InsufficientLiquidity)

        let requiredCollateral = determineCollateralAmount(amount, 15000) // 150% collateral

        let rate = getPoolRate()

        // take fee
        transferToken!(caller, selfAddress!(), poolToken, getPoolFee(amount))

        // create debt contract
        let (encodeImmutableFields, encodeMutableFields) = Debt.encodeFields!(
            caller,
            amount,
            requiredCollateral,
            blockTimeStamp!(),
            rate,
            selfAddress!()
        )

        let time = blockTimeStamp!()
        let value = encodeToByteVec!(time, caller)
        
        // work on this bit
	    let debtId = copyCreateSubContract!{callerAddress!() -> ALPH: minimalContractDeposit!() * 2, poolToken: requiredCollateral}(
		    value,                  // time + caller
		    debtTemplate,
		    encodeImmutableFields,
		    encodeMutableFields
	    )

        totalBorrowed = totalBorrowed + amount

        transferToken!(selfAddress!(), caller, poolToken, amount)

        emit NewDebt(caller, amount, requiredCollateral, rate, value)
    }

    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn repay(contract: ByteVec) -> () {
        let caller = callerAddress!()

        // Load the debt contract
        let debt = Debt(subContractId!(contract))

        // Get the total repayment amount (principal + interest)
        let totalRepayment = debt.calculateRepayment()

        // Get collateral and parent contract
        let collateralAmount = debt.getCollateralAmount()
        let parent = debt.getParentAddress()
        let debtOwner = debt.getDebtor()

        // Debt
        assert!(callerAddress!() == debtOwner, PoolCodes.NotOwner)

        // Ensure this debt belongs to the current pool
        assert!(selfAddress!() == parent, PoolCodes.WrongDebtPool)

        // Transfer repayment amount to pool
        transferToken!(caller, selfAddress!(), poolToken, totalRepayment)

        // Release collateral back to borrower
        transferToken!(selfAddress!(), caller, poolToken, collateralAmount)

        // Update pool balances
        totalPoolAssets = totalPoolAssets + totalRepayment
        totalBorrowed = totalBorrowed - debt.getLoanAmount()

        // Destroy the debt contract
        debt.destroyDebt(caller)

        emit RemoveDebt(caller, contract)
    }

	@using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn liquidate(contract: ByteVec) -> () {
        let debt = Debt(subContractId!(contract))
    
        let totalDebt = debt.calculateRepayment()
        let caller = callerAddress!()
    
        let collateral = debt.getCollateralAmount()
        let parent = debt.getParentAddress()
    
        // verify debt is from pool
        assert!(selfAddress!() == parent, PoolCodes.WrongDebtPool)
    
        let collateralRatio = determineCollateralRatio(totalDebt, collateral)
        assert!(collateralRatio < 15000, PoolCodes.InsufficientCollateral) // Must be below 150% to liquidate
    
        let liquidationPenalty = (collateral * 10) / 100  // 10% liquidation fee
        let liquidationIncentive = (collateral * 5) / 100 // 5% liquidation incentive to caller
    
        let seizedCollateral = collateral - (liquidationPenalty + liquidationIncentive)
    
        // Pay liquidation incentive to caller
        transferToken!(selfAddress!(), caller, ALPH, dustAmount!())
        transferToken!(selfAddress!(), caller, poolToken, liquidationIncentive)

        fees = fees + liquidationPenalty
        totalPoolAssets = totalPoolAssets + seizedCollateral

        debt.destroyDebt(selfAddress!())
    }

    @using(checkExternalCaller = true, updateFields = true)
    pub fn collectFees() -> () {
        checkCaller!(callerAddress!() == admin, 1)

        transferToken!(selfAddress!(), callerAddress!(), poolToken, amount)
    }

    @using(checkExternalCaller = true, assetsInContract = true)
    pub fn destoryPool() -> () {
        checkCaller!(callerAddress!() == admin, 1)

        destroySelf!(admin)
    }
}

TxScript Deposit (
    contract: Pool,
    amount: U256
) {
    let token = getPoolToken()
    contract.deposit{callerAddress!() -> token: amount}(amount)
}

TxScript Withdraw (
    contract: Pool,
    amount: U256
) {
    let sToken = getSPoolToken()
    contract.withdraw{callerAddress!() -> sToken: amount}(amount)
}

TxScript InstantBorrow (
    contract: Pool
)

TxScript RepayDebt (
    contract: Pool
)

TxScript LiquidateDebt (
    contract: Pool
)

