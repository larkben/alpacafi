import "std/fungible_token_interface"

Contract Pool (
    admin: ByteVec,
    debtTemplate: ByteVec,
    poolToken: ByteVec,
    poolDecimals: U256,
    // sPoolToken and Pool values
    name: ByteVec,
    symbol: ByteVec,
    mut sTokenSupply: U256,
    mut exchangeRate: U256,
    mut totalPoolAssets: U256,
    mut depositedAmount: U256,
    mut totalBorrowed: U256,
    mut fees: U256,
    // base rate - determined by governance
    mut baseRate: U256,
    mut poolFee: U256
) implements IFungibleToken {

    event NewDebt(who: Address, loan: U256, collateral: U256, rate: U256, contract: ByteVec)
    event RemoveDebt(who: Address, contract: ByteVec)

    enum PoolCodes {
        CannotDepositZero = 0
        CannotBorrowZero = 1
        InsufficientLiquidity = 2
        InsufficientCollateral = 3
        NoActiveLoan = 4
        NoOverPayment = 5
        WrongDebtPool = 6
        NotOwner = 7
    }

    pub fn getSymbol() -> (ByteVec) {
        return symbol
    }

    pub fn getName() -> (ByteVec) {
        return name
    }

    pub fn getDecimals() -> (U256) {
        return 18
    }

    pub fn getTotalSupply() -> (U256) {
        return 10000000000000000000000000000000000000000
    }

    pub fn getPoolToken() -> (ByteVec) {
        return poolToken
    }

    pub fn getSPoolToken() -> (ByteVec) {
        return selfTokenId!()
    }

    pub fn getAccruedInterest(debt: ByteVec) -> (U256) {
        
        let interest = Debt(debt).getInterestRate()
        let tokenAmount = Debt(debt).getLoanAmount()

        if (interest > 0) {
            // Calculate elapsed time
            let elapsedTime = blockTimeStamp!() - Debt(debt).getTimeCreated()
    
            // Avoid integer truncation: multiply first, then divide
            let gain = (tokenAmount * interest * elapsedTime) / (31556926000 * 10000)
    
            // Calculate 7% flat interest (tokenAmount * 7 / 100)
            let flatInterest = (tokenAmount * 3) / 100
    
            // Return the original amount + accrued interest + flat interest
            return tokenAmount + gain + flatInterest
        } else {
            return tokenAmount
        }
    }

    pub fn getPoolRate() -> (U256) {
        let utilization = (totalBorrowed * 10000) / totalPoolAssets
        
        // Smooth curve that starts at baseRate and increases exponentially with utilization
        // Formula: rate = baseRate + (utilization^2 / 10000) * multiplier
        
        let utilizationSquared = (utilization * utilization) / 10000
        let multiplier = 2000  // This controls how steep the curve gets
        
        // Rate calculation with governance-defined baseRate as input
        // This creates a curve that starts at baseRate and increases based on utilization
        let dynamicRate = baseRate + (utilizationSquared * multiplier) / 10000
        
        // Cap the maximum rate at 2000 (20%)
        if (dynamicRate > 2000) {
          return 2000
        }
        
        return dynamicRate
      }

    pub fn getTotalRepayment(contract: ByteVec) -> (U256) {
        let debt = Debt(subContractId!(contract))

        let totalDebt = debt.calculateRepayment()

        return totalDebt
    }

    @using(checkExternalCaller = false, updateFields = true)
    pub fn getPoolFee(amountIn: U256) -> (U256) {
        let flatFee = (amountIn * poolFee) / 10000            // 300 = 3%

        fees = fees + flatFee

        return flatFee
    }

	@using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn deposit(caller: Address, amount: U256) -> () {

        assert!(amount > 0, PoolCodes.CannotDepositZero)

        transferToken!(caller, selfAddress!(), ALPH, dustAmount!() * 3)
        transferToken!(caller, selfAddress!(), poolToken, amount)

        // Normalize calculations to avoid precision errors
        let precisionFactor = 1000000000000000000 // 1e18
        let totalSTokens = (amount * precisionFactor) / exchangeRate

        sTokenSupply = sTokenSupply + totalSTokens

        transferToken!(selfAddress!(), caller, ALPH, dustAmount!())
        transferToken!(selfAddress!(), caller, selfContractId!(), totalSTokens)

        depositedAmount = depositedAmount + amount
        totalPoolAssets = totalPoolAssets + amount

        exchangeRate = (totalPoolAssets * precisionFactor) / sTokenSupply
    }

    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn withdraw(caller: Address, amount: U256) -> () {

        transferToken!(caller, selfAddress!(), ALPH, dustAmount!() * 3)
        transferToken!(caller, selfAddress!(), selfContractId!(), amount)

        let precisionFactor = 1000000000000000000 // 1e18
        let assetsToReceive = (amount * exchangeRate) / precisionFactor

        assert!(depositedAmount >= assetsToReceive, PoolCodes.InsufficientLiquidity)

        sTokenSupply = sTokenSupply - amount
        totalPoolAssets = totalPoolAssets - assetsToReceive
        depositedAmount = depositedAmount - assetsToReceive

        transferToken!(selfAddress!(), caller, ALPH, dustAmount!() * 3)
        transferToken!(selfAddress!(), caller, poolToken, assetsToReceive)

        // Avoid division by zero
        if (sTokenSupply > 0) {
            exchangeRate = (totalPoolAssets * precisionFactor) / sTokenSupply
        } else {
            exchangeRate = precisionFactor // Reset to 1 ALPH per sALPH when empty
        }
    }

    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn borrow(caller: Address, collateralToken: ByteVec, amountRequest: U256, path: ByteVec) -> () {

        assert!(amountRequest > 0, PoolCodes.CannotBorrowZero)
        assert!(totalPoolAssets - totalBorrowed >= amountRequest, PoolCodes.InsufficientLiquidity)

        let precisionFactor = 1000000000000000000 // 1e18
        let requiredCollateral = PoolFactory(admin).determineCollateralAmount(poolToken, poolDecimals, amountRequest, 15000) // 150% collateral
        let rate = getPoolRate()

        // Take fee
        let flatFee = getPoolFee(amountRequest)
        transferToken!(caller, selfAddress!(), poolToken, flatFee)

        // Create debt contract
        let (encodeImmutableFields, encodeMutableFields) = Debt.encodeFields!(
            caller,
            amountRequest,       // amount of pool token requested
            collateralToken,     // collateral token
            requiredCollateral,
            blockTimeStamp!(),
            rate,
            15000,               // collateralization ratio
            selfAddress!()
        )

        let debtId = copyCreateSubContract!{callerAddress!() -> ALPH: minimalContractDeposit!() * 2, poolToken: requiredCollateral}(
            path,
            debtTemplate,
            encodeImmutableFields,
            encodeMutableFields
        )

        totalBorrowed = totalBorrowed + amount

        transferToken!(selfAddress!(), caller, poolToken, amount)

        //emit NewDebt(caller, amount, requiredCollateral, rate, value)
    }

    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn repay(caller: Address, contract: ByteVec) -> () {

        // Load the debt contract
        let debt = Debt(subContractId!(contract))

        // Get total repayment amount (principal + interest)
        let totalRepayment = debt.calculateRepayment()
        let collateralAmount = debt.getCollateralAmount()
        let parent = debt.getParentAddress()
        let debtOwner = debt.getDebtor()

        // Ensure caller is the debtor
        assert!(caller == debtOwner, PoolCodes.NotOwner)

        // Ensure debt belongs to this pool
        assert!(selfAddress!() == parent, PoolCodes.WrongDebtPool)

        // Transfer repayment amount to pool
        transferToken!(caller, selfAddress!(), poolToken, totalRepayment)

        // Release collateral back to borrower
        transferToken!(selfAddress!(), caller, poolToken, collateralAmount)

        // Update pool balances
        totalPoolAssets = totalPoolAssets + totalRepayment
        totalBorrowed = totalBorrowed - debt.getLoanAmount()

        // Destroy debt contract
        debt.destroyDebt(caller)

        emit RemoveDebt(caller, contract)
    }

    //! the user should be repaying the unpaid debt at this point to redeem on the collateral
	@using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = false, updateFields = true)
    pub fn liquidate(contract: ByteVec) -> () {
        let debt = Debt(subContractId!(contract))
        let adminContract = PoolFactory(admin)
    
        // validate debt comes from this contract
        let parent = debt.getParentAddress()
        assert!(selfAddress!() == parent, PoolCodes.WrongDebtPool)

        let caller = callerAddress!()

        // token
        let oracle = adminContract.getOracleForToken(poolToken)
        
        // collateral info
        let collateral = debt.getCollateralToken()
        let collateralAmount = debt.getCollateralAmount()
        let collateralOracle = adminContract.getOracleForToken(collateralToken)

        // validate debt comes from this contract
        let parent = debt.getParentAddress()

        // 
        let totalDebt = debt.calculateRepayment()
    
        // verify debt is from pool
        assert!(selfAddress!() == parent, PoolCodes.WrongDebtPool)
        
        // edit for multi-collateral
        let collateralRatio = PoolFactory(admin).determineCollateralRatio(
            poolToken,
            totalDebt,
            oracle,
            collateral,
            collateralAmount,
            collateralOracle,
            debt.getRatio()    // 150 minimum but increasing from there for other more speculative tokens ~
        )

        assert!(collateralRatio < 15000, PoolCodes.InsufficientCollateral) // Must be below 150% to liquidate
    
        let liquidationPenalty = (collateral * 8) / 100  // 8% liquidation fee
        let liquidationIncentive = (collateral * 2) / 100 // 2% liquidation incentive to caller
    
        let seizedCollateral = collateral - (liquidationPenalty + liquidationIncentive)
    
        // Pay liquidation incentive to caller
        transferToken!(selfAddress!(), caller, ALPH, dustAmount!())
        transferToken!(selfAddress!(), caller, poolToken, liquidationIncentive)

        fees = fees + liquidationPenalty
        totalPoolAssets = totalPoolAssets + seizedCollateral

        debt.destroyDebt(selfAddress!())
    }

    @using(checkExternalCaller = true, assetsInContract = true)
    pub fn destoryPool() -> () {
        checkCaller!(callerAddress!() == admin, 1)

        destroySelf!(admin)
    }
}