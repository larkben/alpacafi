struct Tokens {
	mut maxLend: U256,
	mut lendingRate: U256
}

Contract LendingPool (
	owner: Address,
	parent: Address,
	lendingAsset: ByteVec, // this is an asset storage contract
	debtTemplate: ByteVec,
	loansActive: U256,
	// params
	maxTime: U256
) {
	mapping [ByteVec, Tokens] tokens
	// max tokens per loan

	enum LendingPoolCodes {
        InvalidCaller = 0
		NotOwner = 1
    }
	
	// add tokens to asset holding for lending
	@using(checkExternalCaller = true)
	pub fn lend(caller: Address, token: ByteVec, amount: U256) -> () {
		// check caller == parent
		checkCaller!(callerAddress!() == parent, LendingPoolCodes.InvalidCaller)

		// only owner of pool can and should add assets
		assert!(caller == owner, LendingPoolCodes.NotOwner)

		// add tokens to asset storage and or create if it doesn't exist already
		if (tokens.contains!(token) == false) {
			
			// create the subContract for asset holding
			// ~ debate here if a mapping is even needed
			let b = Tokens {
				maxLend: 0,
				lendingRate: 0
			}

			tokens.insert!(caller, token, b)

			let (encodeImmutableFields, encodeMutableFields) = LendingAsset.encodeFields!(
				selfAddress!(),
				caller,
				token,
				amount
			)

			let assetContract = copyCreateSubContract!{owner -> ALPH: minimalContractDeposit!() + (dustAmount!() * 2)}(
				token,
				lendingAsset,
				encodeImmutableFields,
				encodeMutableFields
			)
		}

    }

	// add tokens to be withdrawable
	@using(checkExternalCaller = true)
	pub fn withdraw() -> () {
		// check caller == parent
		checkCaller!(callerAddress!() == parent, LendingPoolCodes.InvalidCaller)
	}

	// add tokens for borrowing by loaners
	@using(checkExternalCaller = true)
	pub fn borrow() -> () {
		// check caller == parent
		checkCaller!(callerAddress!() == parent, LendingPoolCodes.InvalidCaller)
	}
}