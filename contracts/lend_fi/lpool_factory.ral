Contract LendingPoolFactory (
	mut admin: Address,
	feeTemplate: ByteVec,
	lendingPoolTemplate: ByteVec,
	lendingAsset: ByteVec,
	fee: U256,
	oracle: ByteVec,
	alpaca: ByteVec
) {
	// mapping(s) | token support
	mapping [ByteVec, PairInfo] tokens

    enum LendingPoolFactoryCodes {
        InvalidCaller = 0
    }

	fn determineCollateralRatio(
        tokenRequested: ByteVec,
        tokenAmount: U256,
        tokenOracle: Bool,
        collateralToken: ByteVec, 
        collateralAmount: U256,
        collateralOracle: Bool,
        threshhold: U256
    ) -> (U256, Bool) {
        if (tokens.contains!(tokenRequested) == true && tokens.contains!(collateralToken)) {
            let mut loanValue = 0
            let mut collateralValue = 0

            // fetch token price
            if (tokenOracle) {
                loanValue = TestOracle(oracle).getValue(tokens[tokenRequested].pair).value
            }
            else {
                loanValue = AlpacaFiOracle(alpaca).getValue(tokens[tokenRequested].pair).value
            }

            // fetch collateral price
            if (collateralOracle) {
                collateralValue = TestOracle(oracle).getValue(tokens[collateralToken].pair).value
            }
            else {
                collateralValue = AlpacaFiOracle(alpaca).getValue(tokens[collateralToken].pair).value
            }

            if (loanValue == 0 || collateralValue == 0) {
                return 0, false
            }

            let collateralDecimals = tokens[collateralToken].decimals
            let tokenDecimals = tokens[tokenRequested].decimals

            // Normalize collateral amount to 18 decimals
            let collateralNormalized = (collateralAmount * (10 |**| 18)) / (10 |**| collateralDecimals)
            let collateralValueUSD = (collateralNormalized * collateralValue) / (10 |**| 8) // Remove 8 decimals

            // Normalize loan amount to 18 decimals
            let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| tokenDecimals)
            let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8) // Remove 8 decimals

            // Compute collateral-to-loan ratio in basis points (10000 = 100%)
            let ratio = (collateralValueUSD * 10000) / loanValueUSD // Multiply before division to avoid precision loss

            if (ratio > threshhold) {
                return ratio, true
            }

            else {
                return ratio, false
            }
        }

        return 0, false
    }
	
	@using(checkExternalCaller = false) 
    pub fn determineCollateralAmount(
        tokenPair: ByteVec,
        tokenDecimals: U256,
        tokenAmount: U256,
        desiredRatio: U256
    ) -> (U256) {
        let loanValue = AlpacaFiOracle(alpaca).getValue(tokenPair).value
        let collateralValue = AlpacaFiOracle(alpaca).getValue(tokenPair).value

        if (loanValue == 0 || collateralValue == 0 || desiredRatio == 0) {
            return 0
        }

        let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| tokenDecimals)
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8)

        let requiredCollateralUSD = (loanValueUSD * desiredRatio) / 10000

        let collateralNormalized = (requiredCollateralUSD * (10 |**| 8)) / collateralValue
        let requiredCollateralAmount = (collateralNormalized * (10 |**| tokenDecimals)) / (10 |**| 18)

        return requiredCollateralAmount
    }
		
	// create lending pool
    pub fn createLendingPool() -> () {

    }
	
	// -----------------------
	
	// update admin
    @using(checkExternalCaller = true, updateFields = true)
    pub fn updateLendingFactoryAdmin(newAdmin: Address) -> () {
        checkCaller!(callerAddress!() == admin, LendingPoolFactoryCodes.InvalidCaller)

        admin = newAdmin
    }
	
	// upgrade functions
    // ....
}
