// ImprovedPool.ral - Enhanced lending pool with dynamic parameters

Contract ImprovedPool (
    registry: Address,
    poolToken: ByteVec,
    poolDecimals: U256,
    name: ByteVec,
    symbol: ByteVec,
    mut sTokenSupply: U256,
    mut exchangeRate: U256,
    mut totalPoolAssets: U256,
    mut depositedAmount: U256,
    mut totalBorrowed: U256,
    mut reserves: U256,
    mut lastUpdateTimestamp: U256,
    mut borrowingEnabled: Bool
) implements IFungibleToken {

    event Deposit(user: Address, amount: U256, sTokensMinted: U256)
    event Withdraw(user: Address, amount: U256, sTokensBurned: U256)
    event Borrow(user: Address, amount: U256, debtId: U256)
    event Repay(user: Address, amount: U256, debtId: U256)
    event ReservesCollected(amount: U256, recipient: Address)
    event StateUpdated(utilizationRate: U256, newExchangeRate: U256)

    enum ErrorCodes {
        CannotDepositZero = 0
        CannotBorrowZero = 1
        InsufficientLiquidity = 2
        InsufficientCollateral = 3
        NoActiveLoan = 4
        InvalidAmount = 5
        BorrowingDisabled = 6
        Unauthorized = 7
        SupplyCapReached = 8
        BorrowCapReached = 9
    }
    
    pub fn getSymbol() -> ByteVec {
        return symbol
    }
    
    pub fn getName() -> ByteVec {
        return name
    }
    
    pub fn getDecimals() -> U256 {
        return 18
    }
    
    pub fn getTotalSupply() -> U256 {
        return 10000000000000000000000000000000000000000
    }
    
    pub fn getPoolToken() -> ByteVec {
        return poolToken
    }
    
    pub fn getSPoolToken() -> ByteVec {
        return selfTokenId!()
    }
    
    pub fn getPoolMetrics() -> (U256, U256, U256, U256, U256) {
        return totalPoolAssets, depositedAmount, totalBorrowed, getUtilizationRate(), reserves
    }
    
    pub fn getUtilizationRate() -> U256 {
        if (totalPoolAssets == 0) {
            return 0
        }
        
        return (totalBorrowed * 10000) / totalPoolAssets
    }
    
    pub fn getInterestRate() -> U256 {
        // Get registry components
        let reg = Registry(addressToContractId!(registry))
        let riskManager = RiskManager(addressToContractId!(reg.getRiskManager()))
        
        // Get token risk parameters
        let tokenParams = riskManager.getTokenRiskParams(poolToken)
        
        // Get the utilization rate
        let utilization = getUtilizationRate()
        
        // Use dynamic interest rate model based on utilization
        if (utilization < 5000) { // < 50%
            return 200 // 2%
        } else if (utilization < 8000) { // 50% - 80%
            return 500 // 5%
        } else if (utilization < 9000) { // 80% - 90%
            return 800 // 8%
        } else {
            return 1500 // 15% (High-risk)
        }
    }
    
    @using(checkExternalCaller = false, updateFields = true)
    pub fn updateState() -> () {
        let reg = Registry(addressToContractId!(registry))
        let riskManager = RiskManager(addressToContractId!(reg.getRiskManager()))
        
        // Calculate time elapsed since last update
        let currentTime = blockTimeStamp!()
        let timeElapsed = currentTime - lastUpdateTimestamp
        
        if (timeElapsed == 0) {
            return
        }
        
        // Calculate interest accrued
        let interestRate = getInterestRate()
        let interestAccrued = (totalBorrowed * interestRate * timeElapsed) / (SECONDS_PER_YEAR * BASIS_POINTS)
        
        if (interestAccrued > 0) {
            // Get reserve factor from risk parameters
            let tokenParams = riskManager.getTokenRiskParams(poolToken)
            let reserveFactor = tokenParams.reserveFactor
            
            // Calculate reserves amount
            let reserveAmount = (interestAccrued * reserveFactor) / BASIS_POINTS
            reserves = reserves + reserveAmount
            
            // Update total pool assets with interest
            totalPoolAssets = totalPoolAssets + interestAccrued
            
            // Update total borrowed with interest
            totalBorrowed = totalBorrowed + interestAccrued
            
            // Update exchange rate
            if (sTokenSupply > 0) {
                let precisionFactor = 1000000000000000000 // 1e18
                exchangeRate = (totalPoolAssets * precisionFactor) / sTokenSupply
            }
        }
        
        // Update last update timestamp
        lastUpdateTimestamp = currentTime
        
        emit StateUpdated(getUtilizationRate(), exchangeRate)
    }
    
    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn deposit(amount: U256) -> U256 {
        let caller = callerAddress!()
        
        assert!(amount > 0, ErrorCodes.CannotDepositZero)
        
        // Update state before any operation
        updateState()
        
        // Check if supply cap is reached
        let reg = Registry(addressToContractId!(registry))
        let riskManager = RiskManager(addressToContractId!(reg.getRiskManager()))
        let tokenParams = riskManager.getTokenRiskParams(poolToken)
        
        assert!(depositedAmount + amount <= tokenParams.supplyCap, ErrorCodes.SupplyCapReached)
        
        transferToken!(caller, selfAddress!(), ALPH, dustAmount!() * 3)
        transferToken!(caller, selfAddress!(), poolToken, amount)
        
        // Normalize calculations to avoid precision errors
        let precisionFactor = 1000000000000000000 // 1e18
        let totalSTokens = (amount * precisionFactor) / exchangeRate
        
        sTokenSupply = sTokenSupply + totalSTokens
        
        transferToken!(selfAddress!(), caller, ALPH, dustAmount!())
        transferToken!(selfAddress!(), caller, selfTokenId!(), totalSTokens)
        
        depositedAmount = depositedAmount + amount
        totalPoolAssets = totalPoolAssets + amount
        
        exchangeRate = (totalPoolAssets * precisionFactor) / sTokenSupply
        
        emit Deposit(caller, amount, totalSTokens)
        
        return totalSTokens
    }
    
    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn withdraw(sTokenAmount: U256) -> U256 {
        let caller = callerAddress!()
        
        // Update state before any operation
        updateState()
        
        transferToken!(caller, selfAddress!(), ALPH, dustAmount!() * 3)
        transferToken!(caller, selfAddress!(), selfTokenId!(), sTokenAmount)
        
        let precisionFactor = 1000000000000000000 // 1e18
        let assetsToReceive = (sTokenAmount * exchangeRate) / precisionFactor
        
        assert!(depositedAmount >= assetsToReceive, ErrorCodes.InsufficientLiquidity)
        
        sTokenSupply = sTokenSupply - sTokenAmount
        totalPoolAssets = totalPoolAssets - assetsToReceive
        depositedAmount = depositedAmount - assetsToReceive
        
        transferToken!(selfAddress!(), caller, ALPH, dustAmount!() * 3)
        transferToken!(selfAddress!(), caller, poolToken, assetsToReceive)
        
        // Avoid division by zero
        if (sTokenSupply > 0) {
            exchangeRate = (totalPoolAssets * precisionFactor) / sTokenSupply
        } else {
            exchangeRate = precisionFactor // Reset to 1:1 when empty
        }
        
        emit Withdraw(caller, assetsToReceive, sTokenAmount)
        
        return assetsToReceive
    }
    
    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn borrow(amount: U256, debtId: U256) -> Bool {
        let caller = callerAddress!()
        
        // Update state before any operation
        updateState()
        
        assert!(borrowingEnabled, ErrorCodes.BorrowingDisabled)
        assert!(amount > 0, ErrorCodes.CannotBorrowZero)
        assert!(totalPoolAssets - totalBorrowed >= amount, ErrorCodes.InsufficientLiquidity)
        
        // Check if borrow cap is reached
        let reg = Registry(addressToContractId!(registry))
        let riskManager = RiskManager(addressToContractId!(reg.getRiskManager()))
        let debtManager = DebtManager(addressToContractId!(reg.getDebtManager()))
        
        let tokenParams = riskManager.getTokenRiskParams(poolToken)
        assert!(totalBorrowed + amount <= tokenParams.borrowCap, ErrorCodes.BorrowCapReached)
        
        // Get debt position and verify it belongs to caller
        let debtPosition = debtManager.getDebtPosition(debtId)
        assert!(debtPosition.active && debtPosition.borrower == caller, ErrorCodes.Unauthorized)
        
        // Add borrow to debt position
        let interestRate = getInterestRate()
        let success = debtManager.borrow(debtId, poolToken, amount, interestRate)
        
        if (success) {
            // Update pool state
            totalBorrowed = totalBorrowed + amount
            
            // Transfer tokens to borrower
            transferToken!(selfAddress!(), caller, poolToken, amount)
            
            emit Borrow(caller, amount, debtId)
        }
        
        return success
    }
    
    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn repay(amount: U256, debtId: U256) -> U256 {
        let caller = callerAddress!()
        
        // Update state before any operation
        updateState()
        
        // Get DebtManager
        let reg = Registry(addressToContractId!(registry))
        let debtManager = DebtManager(addressToContractId!(reg.getDebtManager()))
        
        // Get debt position
        let debtPosition = debtManager.getDebtPosition(debtId)
        assert!(debtPosition.active, ErrorCodes.NoActiveLoan)
        
        // Transfer repayment amount to pool
        transferToken!(caller, selfAddress!(), poolToken, amount)
        
        // Repay debt through DebtManager
        let amountRepaid = debtManager.repayBorrow(debtId, poolToken, amount)
        
        // Update pool state
        if (amountRepaid > 0) {
            // Make sure we don't underflow
            if (amountRepaid > totalBorrowed) {
                totalBorrowed = 0
            } else {
                totalBorrowed = totalBorrowed - amountRepaid
            }
            
            emit Repay(caller, amountRepaid, debtId)
        }
        
        // Refund excess payment if any
        if (amount > amountRepaid) {
            transferToken!(selfAddress!(), caller, poolToken, amount - amountRepaid)
        }
        
        return amountRepaid
    }
    
    @using(checkExternalCaller = true, assetsInContract = true, updateFields = true)
    pub fn collectReserves(amount: U256) -> Bool {
        let reg = Registry(addressToContractId!(registry))
        let treasury = reg.getTreasury()
        
        checkCaller!(callerAddress!() == treasury, ErrorCodes.Unauthorized)
        
        assert!(amount <= reserves, ErrorCodes.InsufficientLiquidity)
        
        reserves = reserves - amount
        
        transferToken!(selfAddress!(), treasury, poolToken, amount)
        
        emit ReservesCollected(amount, treasury)
        
        return true
    }
    
    @using(checkExternalCaller = true, updateFields = true)
    pub fn setBorrowingEnabled(newBorrowingEnabled: Bool) -> Bool {
        let reg = Registry(addressToContractId!(registry))
        let governance = reg.getGovernance()
        
        checkCaller!(callerAddress!() == governance, ErrorCodes.Unauthorized)
        
        borrowingEnabled = newBorrowingEnabled
        
        return true
    }
    
    // Get current token price from oracle via risk manager
    pub fn getTokenPrice() -> U256 {
        let reg = Registry(registry)
        let riskManager = RiskManager(reg.getRiskManager())
        
        return riskManager.getTokenPrice(poolToken)
    }
}