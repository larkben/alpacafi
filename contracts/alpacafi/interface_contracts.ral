// Interfaces

// Extended token with multi-collateral feature
Interface IMultiCollateralToken {
    pub fn getSymbol() -> ByteVec
    pub fn getName() -> ByteVec
    pub fn getDecimals() -> U256
    pub fn getTotalSupply() -> U256
    
    // Multi-collateral functions
    pub fn isCollateralEnabled(tokenAddress: ByteVec) -> Bool
    pub fn getCollateralFactor(tokenAddress: ByteVec) -> U256
    pub fn getLiquidationThreshold(tokenAddress: ByteVec) -> U256
}

// Governance interface
Interface IGovernance {
    pub fn proposeVote(proposal: ByteVec, description: ByteVec, votingPeriod: U256) -> U256
    pub fn castVote(proposalId: U256, support: Bool) -> Bool
    pub fn executeProposal(proposalId: U256) -> Bool
}

// Interest rate model interface
Interface IInterestRateModel {
    pub fn calculateBorrowRate(utilizationRate: U256) -> U256
    pub fn calculateSupplyRate(utilizationRate: U256, reserveFactor: U256) -> U256
}

// Dynamic interest rate model
Contract DynamicInterestRateModel(
    mut baseRate: U256,          // Base interest rate when utilization is 0
    mut multiplier: U256,        // Rate multiplier as utilization increases
    mut jumpMultiplier: U256,    // Multiplier after optimal utilization point
    mut optimal: U256,           // Optimal utilization point (e.g., 8000 = 80%)
    mut governance: Address
) implements IInterestRateModel {
    
    pub fn calculateBorrowRate(utilizationRate: U256) -> U256 {
        // All rates are in basis points (1 = 0.01%)
        
        if (utilizationRate <= optimal) {
            // Normal rate curve: baseRate + (utilization * multiplier)
            return baseRate + (utilizationRate * multiplier) / 10000
        } else {
            // Jump rate curve after optimal utilization
            let normalRate = baseRate + (optimal * multiplier) / 10000
            let excessUtil = utilizationRate - optimal
            let jumpRate = (excessUtil * jumpMultiplier) / 10000
            
            return normalRate + jumpRate
        }
    }
    
    pub fn calculateSupplyRate(utilizationRate: U256, reserveFactor: U256) -> U256 {
        let borrowRate = calculateBorrowRate(utilizationRate)
        
        // Supply rate = borrowRate * utilizationRate * (1 - reserveFactor)
        return (borrowRate * utilizationRate * (10000 - reserveFactor)) / (10000 * 10000)
    }
    
    @using(checkExternalCaller = true, updateFields = true)
    pub fn updateParameters(
        newBaseRate: U256,
        newMultiplier: U256,
        newJumpMultiplier: U256,
        newOptimal: U256
    ) -> () {
        checkCaller!(callerAddress!() == governance, 1)
        
        baseRate = newBaseRate
        multiplier = newMultiplier
        jumpMultiplier = newJumpMultiplier
        optimal = newOptimal
    }
    
    @using(checkExternalCaller = true, updateFields = true)
    pub fn updateGovernance(newGovernance: Address) -> () {
        checkCaller!(callerAddress!() == governance, 2)
        
        governance = newGovernance
    }
}