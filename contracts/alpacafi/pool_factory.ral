// PoolFactory.ral - Creates and manages lending pools

struct PoolInfo {
    tokenId: ByteVec,
    poolAddress: Address,
    tokenDecimals: U256,
    createdAt: U256,
    isActive: Bool
}

Contract PoolFactory (
    registry: Address,
    poolTemplate: ByteVec,
    mut governance: Address,
    mut poolCount: U256
) { 
    // Maps to store pool information instead of dynamic array
    mapping[U256, PoolInfo] pools                 // Index -> PoolInfo
    mapping[ByteVec, U256] tokenToIndex           // TokenId -> Index
    mapping[ByteVec, Bool] tokenExists            // TokenId -> Exists flag
    
    // Events
    event PoolCreated(token: ByteVec, address: Address, name: ByteVec, symbol: ByteVec)
    event PoolDeactivated(token: ByteVec, address: Address)
    event PoolReactivated(token: ByteVec, address: Address)
    event TokenPriceConfigured(token: ByteVec, pricePair: ByteVec, useMainOracle: Bool)
    
    pub fn getPoolsCount() -> U256 {
        return poolCount
    }
    
    pub fn getPoolInfo(index: U256) -> PoolInfo {
        assert!(index < poolCount, 1) // Index out of bounds
        return pools[index]
    }
    
    pub fn findPoolByToken(token: ByteVec) -> (Bool, U256, Address) {
        if (tokenExists.contains!(token)) {
            let index = tokenToIndex[token]
            let poolInfo = pools[index]
            return true, index, poolInfo.poolAddress
        }
        
        return false, 0, nullContractAddress!()
    }
    
    @using(checkExternalCaller = true, updateFields = true, assetsInContract = true)
    pub fn createPool(
        token: ByteVec,
        tokenDecimals: U256,
        name: ByteVec,
        symbol: ByteVec
    ) -> Address {
        // Only governance can create new pools
        checkCaller!(callerAddress!() == governance, 2)
        
        // Check if pool already exists for this token
        let (exists, _, _) = findPoolByToken(token)
        assert!(!exists, 3) // Pool already exists for this token
        
        // Get registry and check if oracle is configured for this token
        let reg = Registry(addressToContractId!(registry))
        let riskManager = RiskManager(addressToContractId!(reg.getRiskManager()))
        
        // Check if token price can be obtained - will assert if not configured
        let tokenPrice = riskManager.getTokenPrice(token)
        assert!(tokenPrice > 0, 4) // Token price not configured or zero
        
        // Encode pool creation parameters
        let (encodedImmFields, encodedMutFields) = ImprovedPool.encodeFields!(
            registry,                // Registry
            token,                   // Token ID
            tokenDecimals,           // Decimals
            name,                    // Pool name
            symbol,                  // Pool symbol
            0,                       // sTokenSupply
            1000000000000000000,     // exchangeRate (1.0 in 1e18 precision)
            0,                       // totalPoolAssets
            0,                       // depositedAmount
            0,                       // totalBorrowed
            0,                       // reserves
            blockTimeStamp!(),       // lastUpdateTimestamp
            true                     // borrowingEnabled
        )
        
        // Create pool contract
        let poolAddress = createContract!{callerAddress!() -> ALPH : minimalContractDeposit!() * 2}(
            poolTemplate, 
            encodedImmFields, 
            encodedMutFields
        )
        
        // Create pool info
        let poolInfo = PoolInfo {
            tokenId: token,
            poolAddress: contractIdToAddress!(poolAddress),
            tokenDecimals: tokenDecimals,
            createdAt: blockTimeStamp!(),
            isActive: true
        }
        
        // Store pool info in maps
        pools.insert!(governance, poolCount, poolInfo)
        tokenToIndex.insert!(governance, token, poolCount)
        tokenExists.insert!(governance, token, true)
        
        // Increment pool count
        let currentIndex = poolCount
        poolCount = poolCount + 1
        
        // Register pool in the registry
        reg.registerPool(contractIdToAddress!(poolAddress), token)
        
        emit PoolCreated(token, contractIdToAddress!(poolAddress), name, symbol)
        
        return poolAddress
    }
    
    @using(checkExternalCaller = true, updateFields = true)
    pub fn setPoolStatus(tokenId: ByteVec, active: Bool) -> Bool {
        // Only governance can update pool status
        checkCaller!(callerAddress!() == governance, 5)
        
        // Find the pool
        let (exists, index, address) = findPoolByToken(tokenId)
        assert!(exists, 6) // Pool not found
        
        // Update pool status
        let poolInfo = pools[index]
        let updatedPool = PoolInfo {
            tokenId: poolInfo.tokenId,
            poolAddress: poolInfo.poolAddress,
            tokenDecimals: poolInfo.tokenDecimals,
            createdAt: poolInfo.createdAt,
            isActive: active
        }
        
        pools[index] = updatedPool
        
        if (active) {
            emit PoolReactivated(tokenId, address)
        } else {
            emit PoolDeactivated(tokenId, address)
        }
        
        return true
    }
    
    @using(checkExternalCaller = true, assetsInContract = true)
    pub fn configureTokenPrice(
        token: ByteVec,
        pricePair: ByteVec,
        initialPrice: U256,
        useMainOracle: Bool
    ) -> Bool {
        // Only governance can configure token prices
        checkCaller!(callerAddress!() == governance, 7)
        
        // Get registry and oracles
        let reg = Registry(registry)
        let riskManager = RiskManager(reg.getRiskManager())
        
        // Select oracle based on parameter
        let mut oracle = nullContractAddress!()
        if (mainOracle) {
            let oracle = reg.getMainOracle()
        }
        else {
            let oracle = reg.getTestOracle()
        }
        let oracle = AlpacaFiOracle(oracleAddr)
        
        // Add price pair to oracle
        oracle.insertPair{callerAddress!() -> ALPH: mapEntryDeposit!()}(
            pricePair,
            token,
            initialPrice,
            8 // Standard 8 decimals for prices
        )
        
        // Configure risk manager to use this oracle pair
        riskManager.setTokenOraclePair{callerAddress!() -> ALPH: mapEntryDeposit!()}(
            token,
            pricePair,
            8,
            useMainOracle
        )
        
        emit TokenPriceConfigured(token, pricePair, useMainOracle)
        
        return true
    }
    
    @using(checkExternalCaller = true, assetsInContract = true)
    pub fn configureTokenRiskParams(
        token: ByteVec,
        borrowingEnabled: Bool,
        collateralFactor: U256,
        liquidationThreshold: U256,
        liquidationPenalty: U256,
        borrowCap: U256,
        supplyCap: U256,
        reserveFactor: U256
    ) -> Bool {
        // Only governance can configure risk parameters
        checkCaller!(callerAddress!() == governance, 8)
        
        // Get registry and risk manager
        let reg = Registry(registry)
        let riskManager = RiskManager(reg.getRiskManager())
        
        // Set risk parameters
        riskManager.setTokenRiskParams{callerAddress!() -> ALPH: mapEntryDeposit!()}(
            token,
            borrowingEnabled,
            collateralFactor,
            liquidationThreshold,
            liquidationPenalty,
            borrowCap,
            supplyCap,
            reserveFactor
        )
        
        return true
    }
    
    @using(checkExternalCaller = true, updateFields = true)
    pub fn updateGovernance(newGovernance: Address) -> () {
        checkCaller!(callerAddress!() == governance, 9)
        governance = newGovernance
    }
    
    // Helper function to pre-allocate map entries
    @using(checkExternalCaller = true, assetsInContract = true)
    pub fn prepareForPools(numPools: U256) -> () {
        checkCaller!(callerAddress!() == governance, 10)
        
        // Each pool requires 3 map entries (3 maps per pool)
        let entriesNeeded = numPools * 3
        let deposit = mapEntryDeposit!() * entriesNeeded
        
        // Ensure we have enough ALPH for the map entries
        assert!(selfBalance!() >= deposit, 11)
    }
    
    // Comprehensive function to create a new token pool with all required configuration
    @using(checkExternalCaller = true, assetsInContract = true)
    pub fn createTokenPoolWithOracle(
        token: ByteVec,
        tokenDecimals: U256,
        name: ByteVec,
        symbol: ByteVec,
        pricePair: ByteVec,
        initialPrice: U256,
        collateralFactor: U256,
        liquidationThreshold: U256,
        liquidationPenalty: U256,
        borrowCap: U256,
        supplyCap: U256,
        reserveFactor: U256,
        useMainOracle: Bool
    ) -> Address {
        // Only governance can create new pools with complete configuration
        checkCaller!(callerAddress!() == governance, 12)
        
        // Step 1: Configure token price oracle
        configureTokenPrice(
            token,
            pricePair,
            initialPrice,
            useMainOracle
        )
        
        // Step 2: Configure risk parameters
        configureTokenRiskParams(
            token,
            true, // borrowingEnabled
            collateralFactor,
            liquidationThreshold,
            liquidationPenalty,
            borrowCap,
            supplyCap,
            reserveFactor
        )
        
        // Step 3: Create the pool
        let poolAddress = createPool(
            token,
            tokenDecimals,
            name,
            symbol
        )
        
        return poolAddress
    }
}