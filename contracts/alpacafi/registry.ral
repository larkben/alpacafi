// Registry.ral - Central hub for protocol coordination
Contract Registry (
    admin: Address,
    governance: Address,
    poolFactory: Address,
    riskManager: Address,
    oracleManager: Address,
    debtManager: Address,
    treasury: Address,
    mainOracle: Address,      // Main price oracle
    testOracle: Address,      // Test price oracle
    mut poolsCount: U256
) {
    // Store pools by token ID
    mapping[ByteVec, Address] pools
    
    // Events
    event PoolAdded(poolId: U256, poolAddress: Address, token: ByteVec)
    event ComponentUpdated(componentName: ByteVec, newAddress: Address)
    
    pub fn getPoolFactory() -> Address {
        return poolFactory
    }
    
    pub fn getRiskManager() -> Address {
        return riskManager
    }
    
    pub fn getOracleManager() -> Address {
        return oracleManager
    }
    
    pub fn getDebtManager() -> Address {
        return debtManager
    }
    
    pub fn getTreasury() -> Address {
        return treasury
    }
    
    pub fn getGovernance() -> Address {
        return governance
    }
    
    pub fn getMainOracle() -> Address {
        return mainOracle
    }
    
    pub fn getTestOracle() -> Address {
        return testOracle
    }
    
    pub fn getPoolByToken(token: ByteVec) -> Address {
        if (pools.contains!(token)) {
            return pools[token]
        }
        return nullContractAddress!()
    }
    
    @using(checkExternalCaller = true, updateFields = true, assetsInContract = true)
    pub fn registerPool(poolAddress: Address, token: ByteVec) -> (U256) {
        // Only pool factory can register pools
        checkCaller!(callerAddress!() == poolFactory, 1)
        
        let poolId = poolsCount
        poolsCount = poolsCount + 1
        
        // Store pool in map with deposit
        pools.insert!(admin, token, poolAddress)
        
        emit PoolAdded(poolId, poolAddress, token)
        
        return poolId
    }
}