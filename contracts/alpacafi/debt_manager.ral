// DebtManager.ral - Manages borrowing, collateral, and debt positions

struct DebtPosition {
    mut borrower: Address,
    mut contractId: ByteVec,
    mut active: Bool,
    mut createdAt: U256,
    mut lastUpdatedAt: U256
}

Contract DebtManager (
    registry: Address,
    debtTemplate: ByteVec,
    mut dynamicArray: ByteVec,
    mut governance: Address,
    mut debtCount: U256
) { 
    // Debt ID => Debt Position
    mapping[U256, DebtPosition] debtPositions
    
    // Borrower => Array of Debt IDs
    mapping[Address, ByteVec] borrowerDebts
    
    // Events
    event DebtCreated(debtId: U256, borrower: Address, contractId: ByteVec)
    event DebtUpdated(debtId: U256, action: ByteVec)
    event DebtRepaid(debtId: U256, borrower: Address)
    event DebtLiquidated(debtId: U256, borrower: Address, liquidator: Address)
    
    pub fn getDebtPosition(debtId: U256) -> DebtPosition {
        assert!(debtPositions.contains!(debtId), 1) // Debt position doesn't exist

        return debtPositions[debtId]
    }
    
    pub fn getBorrowerDebts(borrower: Address) -> (ByteVec) {
        if (borrowerDebts.contains!(borrower)) {
            return borrowerDebts[borrower]
        }
        return b`` // null
    }
    
    pub fn checkHealthFactor(debtId: U256) -> (U256, Bool) {
        let debtPosition = getDebtPosition(debtId)
        assert!(debtPosition.active, 2) // Debt position not active
        
        let reg = Registry(addressToContractId!(registry))
        let riskManager = RiskManager(addressToContractId!(reg.getRiskManager()))
        
        // return health factor
        return riskManager.checkHealthFactor(debtId)
    }
    
    @using(checkExternalCaller = false, updateFields = true)
    pub fn createDebtPosition(borrower: Address) -> (U256, ByteVec) {
        // Create unique debt ID
        let debtId = debtCount
        debtCount = debtCount + 1
        
        // Create the debt contract
        let (encodeImmutableFields, encodeMutableFields) = MultiDebt.encodeFields!(
            borrower,
            blockTimeStamp!(),
            debtId,
            selfAddress!(),
            0,
            0
        )
        
        let debtContractId = copyCreateSubContract!{callerAddress!() -> ALPH: minimalContractDeposit!() * 2}(
            encodeToByteVec!(debtCount, borrower, blockTimeStamp!()),
            debtTemplate,
            encodeImmutableFields,
            encodeMutableFields
        )
        
        // Store debt position
        let debtPosition = DebtPosition {
            borrower: borrower,
            contractId: debtContractId,
            active: true,
            createdAt: blockTimeStamp!(),
            lastUpdatedAt: blockTimeStamp!()
        }
        
        debtPositions.insert!(governance, debtId, debtPosition)
        
        // Update borrower's debts
        let currentDebts = b`` // null default
        
        if (!borrowerDebts.contains!(borrower)) {
            // insert since debt doesn't exist
            borrowerDebts.insert!(governance, borrower, currentDebts)
        }
        
        // push to array (u256)
        let dynamicArrayContract = DynamicArrayForInt(dynamicArray)
        let array = dynamicArrayContract.push(borrowerDebts[borrower], debtId)
        
        borrowerDebts[borrower] = array
        
        emit DebtCreated(debtId, borrower, debtContractId)
        
        return debtId, debtContractId
    }
    
    @using(checkExternalCaller = false, updateFields = true)
    pub fn borrow(
        debtId: U256, 
        token: ByteVec, 
        amount: U256, 
        interestRate: U256
    ) -> Bool {
        let debtPosition = getDebtPosition(debtId)
        assert!(debtPosition.active, 3) // Debt position not active
        
        let reg = Registry(addressToContractId!(registry))
        let riskManager = RiskManager(addressToContractId!(reg.getRiskManager()))
        
        // Get the pool address for this token
        let pool = reg.getPoolByToken(token)
        assert!(pool != nullContractAddress!(), 4) // Pool not found for token
        
        // Get the debt contract
        let debt = MultiDebt(subContractId!(debtPosition.contractId))
        
        // Add the borrow position
        debt.addBorrow(token, amount, interestRate, pool)
        
        // Check health factor after borrowing
        let (healthFactor, isHealthy) = checkHealthFactor(debtId)
        assert!(isHealthy, 5) // Borrowing would make position unhealthy
        
        // Update debt position timestamp
        let updatedPosition = DebtPosition {
            borrower: debtPosition.borrower,
            contractId: debtPosition.contractId,
            active: debtPosition.active,
            createdAt: debtPosition.createdAt,
            lastUpdatedAt: blockTimeStamp!()
        }
        
        debtPositions[debtId] = updatedPosition
        
        emit DebtUpdated(debtId, b`borrow`)
        
        return true
    }
    
    @using(checkExternalCaller = false, updateFields = true)
    pub fn addCollateral(
        debtId: U256, 
        token: ByteVec, 
        amount: U256
    ) -> Bool {
        let debtPosition = getDebtPosition(debtId)
        assert!(debtPosition.active, 6) // Debt position not active
        
        let reg = Registry(addressToContractId!(registry))
        
        // Get the pool address for this token
        let pool = reg.getPoolByToken(token)
        assert!(pool != nullContractAddress!(), 7) // Pool not found for token
        
        // Get the debt contract
        let debt = MultiDebt(subContractId!(debtPosition.contractId))
        
        // Add the collateral position
        debt.addCollateral(token, amount, pool)
        
        // Update debt position timestamp
        let updatedPosition = DebtPosition {
            borrower: debtPosition.borrower,
            contractId: debtPosition.contractId,
            active: debtPosition.active,
            createdAt: debtPosition.createdAt,
            lastUpdatedAt: blockTimeStamp!()
        }

        debtPositions[debtId] = updatedPosition
        
        emit DebtUpdated(debtId, b`addCollateral`)
        
        return true
    }
    
    @using(checkExternalCaller = false, updateFields = true)
    pub fn repayBorrow(
        debtId: U256, 
        token: ByteVec, 
        amount: U256
    ) -> U256 {
        let debtPosition = getDebtPosition(debtId)
        assert!(debtPosition.active, 8) // Debt position not active
        
        // Get the debt contract
        let debt = MultiDebt(subContractId!(debtPosition.contractId))
        
        // Repay the borrow
        let amountRepaid = debt.repayBorrow(token, amount)
        
        // Update debt position timestamp
        let updatedPosition = DebtPosition {
            borrower: debtPosition.borrower,
            contractId: debtPosition.contractId,
            active: debtPosition.active,
            createdAt: debtPosition.createdAt,
            lastUpdatedAt: blockTimeStamp!()
        }
        
        debtPositions[debtId] = updatedPosition
        
        emit DebtUpdated(debtId, b`repayBorrow`)
        
        return amountRepaid
    }
    
    @using(checkExternalCaller = false, updateFields = true)
    pub fn removeCollateral(
        debtId: U256, 
        token: ByteVec, 
        amount: U256
    ) -> Bool {
        let debtPosition = getDebtPosition(debtId)
        assert!(debtPosition.active, 9) // Debt position not active
        
        // Get the debt contract
        let debt = MultiDebt(subContractId!(debtPosition.contractId))
        
        // Remove the collateral
        let success = debt.removeCollateral(token, amount)
        
        if (success) {
            // Check health factor after removing collateral
            let (healthFactor, isHealthy) = checkHealthFactor(debtId)
            assert!(isHealthy, 10) // Removing collateral would make position unhealthy
            
            // Update debt position timestamp
            let updatedPosition = DebtPosition {
                borrower: debtPosition.borrower,
                contractId: debtPosition.contractId,
                active: debtPosition.active,
                createdAt: debtPosition.createdAt,
                lastUpdatedAt: blockTimeStamp!()
            }

            debtPositions[debtId] = updatedPosition
            
            emit DebtUpdated(debtId, b`removeCollateral`)
        }
        
        return success
    }
    
    @using(checkExternalCaller = false, updateFields = true)
    pub fn closeDebtPosition(debtId: U256) -> Bool {
        let debtPosition = getDebtPosition(debtId)
        assert!(debtPosition.active, 11) // Debt position not active
        
        let debt = MultiDebt(subContractId!(debtPosition.contractId))
        
        // Check if all borrows have been repaid
        let borrowPositionsCount = debt.getBorrowPositionsCount()
        assert!(borrowPositionsCount == 0, 12) // Not all borrows have been repaid
        
        // Mark debt position as inactive
        let updatedPosition = DebtPosition {
            borrower: debtPosition.borrower,
            contractId: debtPosition.contractId,
            active: false,
            createdAt: debtPosition.createdAt,
            lastUpdatedAt: blockTimeStamp!()
        }
        
        debtPositions[debtId] = updatedPosition
        
        emit DebtRepaid(debtId, debtPosition.borrower)
        
        return true
    }
    
    @using(checkExternalCaller = false, updateFields = true)
    pub fn liquidatePosition(debtId: U256, liquidator: Address) -> Bool {
        let debtPosition = getDebtPosition(debtId)
        assert!(debtPosition.active, 13) // Debt position not active
        
        // Check if position is unhealthy
        let (healthFactor, isHealthy) = checkHealthFactor(debtId)
        assert!(!isHealthy, 14) // Position is not eligible for liquidation
        
        // Mark debt position as inactive (liquidated)
        let updatedPosition = DebtPosition {
            borrower: debtPosition.borrower,
            contractId: debtPosition.contractId,
            active: false,
            createdAt: debtPosition.createdAt,
            lastUpdatedAt: blockTimeStamp!()
        }
        
        debtPositions[debtId] = updatedPosition
        
        emit DebtLiquidated(debtId, debtPosition.borrower, liquidator)
        
        return true
    }
    
    // Function to get all the active debt IDs for monitoring
    pub fn getActiveDebtIds() -> ByteVec {
        let dynamicArrayContract = DynamicArrayForInt(dynamicArray)
        let mut activeIds = b``
        
        for (let mut i = 0; i < debtCount; i = i + 1) {
            if (debtPositions.contains!(i)) {
                let position = debtPositions[i]
                if (position.active) {
                    activeIds = dynamicArrayContract.push(activeIds, i)
                }
            }
        }
        
        return activeIds
    }
    
    // Function to get details about a debt position, including collateral and borrows
    pub fn getPositionDetails(debtId: U256) -> (Address, Bool, U256, U256, U256) {
        let debtPosition = getDebtPosition(debtId)
        let debt = MultiDebt(subContractId!(debtPosition.contractId))
        
        // Get counts
        let borrowCount = debt.getBorrowPositionsCount()
        let collateralCount = debt.getCollateralPositionsCount()
        
        // Return details
        return debtPosition.borrower, debtPosition.active, debtPosition.createdAt, borrowCount, collateralCount
    }
    
    @using(checkExternalCaller = true, updateFields = true)
    pub fn updateGovernance(newGovernance: Address) -> () {
        checkCaller!(callerAddress!() == governance, 15)
        governance = newGovernance
    }
    
    @using(checkExternalCaller = true, updateFields = true)
    pub fn updateDynamicArray(newDynamicArray: ByteVec) -> () {
        checkCaller!(callerAddress!() == governance, 16)
        dynamicArray = newDynamicArray
    }
}