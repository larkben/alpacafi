// LiquidationManager.ral - Handles liquidations for unhealthy positions

// LiquidationManager.ral - Using only events for tracking liquidations
Contract LiquidationManager (
    registry: Address,
    mut governance: Address
) {
    // Events
    event PositionLiquidated(
        debtId: U256, 
        borrower: Address, 
        liquidator: Address, 
        collateralToken: ByteVec, 
        debtToken: ByteVec,
        debtAmount: U256,
        collateralAmount: U256,
        bonus: U256
    )
    
    fn min(a: U256, b: U256) -> U256 {
        if (a < b) {
            return a
        }
        return b
    }
    
    @using(checkExternalCaller = false, assetsInContract = true, preapprovedAssets = true, updateFields = true)
    pub fn liquidatePosition(
        debtId: U256, 
        debtToken: ByteVec,
        collateralToken: ByteVec,
        debtAmount: U256
    ) -> (Bool, U256) {
        let liquidator = callerAddress!()
        
        // Get registry components
        let registry = Registry(registry)
        let debtManager = DebtManager(registry.getDebtManager())
        let riskManager = RiskManager(registry.getRiskManager())
        let oracleManager = OracleManager(registry.getOracleManager())
        
        // Get the debt position
        let debtPosition = debtManager.getDebtPosition(debtId)
        assert!(debtPosition.active, 1) // Position not active
        
        // Check if position is liquidatable
        let (healthFactor, isHealthy) = debtManager.checkHealthFactor(debtId)
        assert!(!isHealthy, 2) // Position is not liquidatable
        
        // Get debt contract
        let debt = MultiDebt(subContractId!(debtPosition.contractId))
        
        // Verify the borrower has debt in this token
        let totalDebtAmount = debt.calculateRepayment(debtToken)
        assert!(totalDebtAmount > 0, 3) // No debt in this token
        
        // Cap the liquidation amount
        let mut liquidationAmount = 0
        
        if (debtAmount > totalDebtAmount) {
            liquidationAmount = totalDebtAmount
        } else {
            liquidationAmount = debtAmount
        }
        
        // Calculate collateral to seize based on oracle prices
        let tokenPrice = oracleManager.getPrice(debtToken).value
        let collateralPrice = oracleManager.getPrice(collateralToken).value
        
        // Get liquidation bonus from risk parameters
        let debtTokenParams = riskManager.getTokenRiskParams(debtToken)
        let liquidationBonus = debtTokenParams.liquidationPenalty
        
        // Calculate collateral equivalent value with bonus (105-110% typically)
        let collateralEquivalent = (liquidationAmount * tokenPrice * (10000 + liquidationBonus)) / (collateralPrice * 10000)
        
        // Verify borrower has enough collateral
        let hasCollateral = debt.hasCollateral(collateralToken)
        assert!(hasCollateral, 4) // Borrower has no collateral in this token
        
        let (_, collateralPos) = debt.getCollateralPosition(collateralToken)
        let collateralAmount = collateralPos.amount
        
        assert!(collateralAmount >= collateralEquivalent, 5) // Not enough collateral to seize
        
        // Get pool addresses
        let debtPool = registry.getPoolByToken(debtToken)
        let collateralPool = registry.getPoolByToken(collateralToken)
        
        assert!(debtPool != zeroAddress!() && collateralPool != zeroAddress!(), 6) // Pool not found
        
        // Transfer debt tokens from liquidator to debt pool
        transferToken!(liquidator, debtPool, debtToken, liquidationAmount)
        
        // Repay the debt
        let pool = ImprovedPool(debtPool)
        let amountRepaid = pool.repay(liquidationAmount, debtId)
        
        // Remove collateral from borrower's position
        let success = debt.removeCollateral(collateralToken, collateralEquivalent)
        
        if (success) {
            // Transfer seized collateral to liquidator
            transferToken!(collateralPool, liquidator, collateralToken, collateralEquivalent)
            
            // Calculate liquidation bonus amount
            let bonusAmount = (collateralEquivalent * liquidationBonus) / (10000 + liquidationBonus)
            
            // Emit liquidation event instead of storing in state
            emit PositionLiquidated(
                debtId, 
                debtPosition.borrower, 
                liquidator, 
                collateralToken, 
                debtToken,
                liquidationAmount,
                collateralEquivalent,
                bonusAmount
            )
            
            // Mark position as liquidated if no more borrows
            if (debt.getBorrowPositionsCount() == 0) {
                debtManager.liquidatePosition(debtId, liquidator)
            }
            
            return true, collateralEquivalent
        }
        
        return false, 0
    }
    
    @using(checkExternalCaller = false)
    pub fn checkLiquidatable(debtId: U256) -> (Bool, U256) {
        // Get registry components
        let registry = Registry(registry)
        let debtManager = DebtManager(registry.getDebtManager())
        
        // Check health factor
        let (healthFactor, isHealthy) = debtManager.checkHealthFactor(debtId)
        
        return !isHealthy, healthFactor
    }
    
    @using(checkExternalCaller = true, updateFields = true)
    pub fn updateGovernance(newGovernance: Address) -> () {
        checkCaller!(callerAddress!() == governance, 7)
        governance = newGovernance
    }
}