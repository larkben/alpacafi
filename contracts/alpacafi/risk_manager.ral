// RiskManager.ral - Fixed to use RALPH-compatible mapping

struct TokenRiskParams {
    // All in basis points (10000 = 100%)
    borrowingEnabled: Bool,      // Whether borrowing is enabled
    collateralFactor: U256,      // Max percentage of collateral value that can be borrowed (e.g., 7500 = 75%)
    liquidationThreshold: U256,  // Percentage at which position can be liquidated (e.g., 8250 = 82.5%)
    liquidationPenalty: U256,    // Penalty added during liquidation (e.g., 500 = 5%)
    borrowCap: U256,             // Maximum amount that can be borrowed from the protocol
    supplyCap: U256,             // Maximum amount that can be supplied to the protocol
    reserveFactor: U256          // Percentage of interest that goes to reserves (e.g., 1000 = 10%)
}

Contract RiskManager (
    registry: Address,
    mut governance: Address
) {
    // Token ID => Risk Parameters
    mapping[ByteVec, TokenRiskParams] tokenRiskParams
    
    // Flattened collateral pair eligibility mappings
    // Key format: collateralToken + borrowToken => Bool
    mapping[ByteVec, Bool] collateralPairEligibility

    mapping[ByteVec, PairInfo] tokenPairs
    
    // Events
    event RiskParamsUpdated(token: ByteVec, collateralFactor: U256, liquidationThreshold: U256)
    event CollateralPairUpdated(collateralToken: ByteVec, borrowToken: ByteVec, eligible: Bool)

    fn getTokenPairInfo() -> PairInfo {

    }
    
    // Helper function to create compound key
    fn createPairKey(collateralToken: ByteVec, borrowToken: ByteVec) -> ByteVec {
        return encodeToByteVec!(collateralToken, borrowToken)
    }
    
    // Default risk parameters
    fn getDefaultRiskParams() -> TokenRiskParams {

        let b = TokenRiskParams {
            borrowingEnabled: false,
            collateralFactor: 7500,     // 75%
            liquidationThreshold: 8250, // 82.5%
            liquidationPenalty: 500,    // 5%
            borrowCap: 1000000000000000000000000000, // 1 billion tokens
            supplyCap: 1000000000000000000000000000, // 1 billion tokens
            reserveFactor: 1000         // 10%
        }

        return b
    }
    
    pub fn getTokenRiskParams(token: ByteVec) -> TokenRiskParams {
        if (tokenRiskParams.contains!(token)) {
            return tokenRiskParams[token]
        }
        
        return getDefaultRiskParams()
    }
    
    pub fn canUseAsCollateral(collateralToken: ByteVec, borrowToken: ByteVec) -> Bool {
        let pairKey = createPairKey(collateralToken, borrowToken)
        
        if (collateralPairEligibility.contains!(pairKey)) {
            return collateralPairEligibility[pairKey]
        }
        
        return false // By default, pairs are not eligible
    }
    
    // Modified to work with the MultiDebt implementation
    pub fn checkHealthFactor(debtId: U256) -> (U256, Bool) {
        let registry = Registry(registry)
        let debtManager = DebtManager(registry.getDebtManager())
        
        // Get the debt position
        let debtPosition = debtManager.getDebtPosition(debtId)
        let debt = MultiDebt(subContractId!(debtPosition.contractId))
        
        let totalBorrowValueInUSD = 0
        let totalCollateralValueInUSD = 0
        
        // Calculate total borrow value by iterating through all borrow positions
        let borrowCount = debt.getBorrowPositionsCount()
        let mut i = 0
        
        while (i < borrowCount) {
            let token = debt.getBorrowTokenAtIndex(i)
            let (exists, position) = debt.getBorrowPosition(token)
            
            if (exists) {
                let totalDebtForToken = debt.calculateRepayment(token)

                let condition = tokenPairs[token]
                let mut tokenPrice = 0

                if (condition.oracle) {
                    tokenPrice = TestOracle(oracle).getValue(tokenPairs[tokenRequested].pair).value
                }
                else {
                    tokenPrice = AlpacaFiOracle(alpaca).getValue(tokenPairs[tokenRequested].pair).value
                }
                
                // Convert to USD value (assuming price is in USD with 8 decimals)
                let borrowValueInUSD = (totalDebtForToken * tokenPrice) / (10 |**| 8)
                totalBorrowValueInUSD = totalBorrowValueInUSD + borrowValueInUSD
            }
            
            i = i + 1
        }
        
        // Calculate total collateral value by iterating through all collateral positions
        let collateralCount = debt.getCollateralPositionsCount()
        let mut j = 0
        
        while (j < collateralCount) {
            let token = debt.getCollateralTokenAtIndex(j)
            let (exists, position) = debt.getCollateralPosition(token)
            
            if (exists) {
                let condition = tokenPairs[token]
                let mut tokenPrice = 0

                if (condition.oracle) {
                    tokenPrice = TestOracle(oracle).getValue(tokenPairs[tokenRequested].pair).value
                }
                else {
                    tokenPrice = AlpacaFiOracle(alpaca).getValue(tokenPairs[tokenRequested].pair).value
                }

                let riskParams = getTokenRiskParams(token)
                
                // Convert to USD value and apply collateral factor
                let collateralValueInUSD = (position.amount * tokenPrice) / (10 |**| 8)
                let adjustedCollateralValue = (collateralValueInUSD * riskParams.collateralFactor) / 10000
                
                totalCollateralValueInUSD = totalCollateralValueInUSD + adjustedCollateralValue
            }
            
            j = j + 1
        }
        
        // Calculate health factor (scaled by 10000 for precision)
        let healthFactor = 0
        if (totalBorrowValueInUSD > 0) {
            healthFactor = (totalCollateralValueInUSD * 10000) / totalBorrowValueInUSD
        } else {
            healthFactor = 100000 // Max health if no borrows
        }
        
        // Health factor below 1.0 (10000) means undercollateralized
        return healthFactor, healthFactor >= 10000
    }
    
    @using(checkExternalCaller = true, updateFields = true, assetsInContract = true)
    pub fn setTokenRiskParams(
        token: ByteVec,
        borrowingEnabled: Bool,
        collateralFactor: U256,
        liquidationThreshold: U256,
        liquidationPenalty: U256,
        borrowCap: U256,
        supplyCap: U256,
        reserveFactor: U256
    ) -> () {
        checkCaller!(callerAddress!() == governance, 1)
        
        // Validate parameters
        assert!(collateralFactor <= 9000, 2) // Max 90% collateral factor
        assert!(liquidationThreshold > collateralFactor, 3) // Must have a buffer
        assert!(liquidationThreshold <= 9500, 4) // Max 95% liquidation threshold
        assert!(liquidationPenalty <= 2000, 5) // Max 20% liquidation penalty
        assert!(reserveFactor <= 5000, 6) // Max 50% reserve factor
        
        let params = TokenRiskParams {
            borrowingEnabled: borrowingEnabled,
            collateralFactor: collateralFactor,
            liquidationThreshold: liquidationThreshold,
            liquidationPenalty: liquidationPenalty,
            borrowCap: borrowCap,
            supplyCap: supplyCap,
            reserveFactor: reserveFactor
        }
        
        // Check if entry exists, otherwise create it
        if (tokenRiskParams.contains!(token)) {
            tokenRiskParams[token] = params
        } else {
            tokenRiskParams.insert!(governance, token, params)
        }
        
        emit RiskParamsUpdated(token, collateralFactor, liquidationThreshold)
    }
    
    @using(checkExternalCaller = true, updateFields = true, assetsInContract = true)
    pub fn setCollateralPair(
        collateralToken: ByteVec, 
        borrowToken: ByteVec, 
        eligible: Bool
    ) -> () {
        checkCaller!(callerAddress!() == governance, 1)
        
        // Create compound key for the pair
        let pairKey = createPairKey(collateralToken, borrowToken)
        
        // Check if entry exists, otherwise create it
        if (collateralPairEligibility.contains!(pairKey)) {
            collateralPairEligibility[pairKey] = eligible
        } else {
            collateralPairEligibility.insert!(governance, pairKey, eligible)
        }
        
        emit CollateralPairUpdated(collateralToken, borrowToken, eligible)
    }
    
    @using(checkExternalCaller = true, updateFields = true)
    pub fn updateGovernance(newGovernance: Address) -> () {
        checkCaller!(callerAddress!() == governance, 1)
        governance = newGovernance
    }
    
    @using(checkExternalCaller = true, assetsInContract = true)
    pub fn prepareForTokens(numTokens: U256, numPairs: U256) -> () {
        checkCaller!(callerAddress!() == governance, 7)
        
        // Calculate total entries needed
        let totalEntries = numTokens + numPairs
        let deposit = mapEntryDeposit!() * totalEntries
        
        // Ensure we have enough ALPH for the map entries
        assert!(selfBalance!() >= deposit, 8)
    }

    // oracle support
    @using(checkExternalCaller = true, preapprovedAssets = true)
    pub fn setDebtOraclePairs(token: ByteVec, pair: ByteVec, decimals: U256, oracle: Bool, add: Bool) -> () {
        checkCaller!(callerAddress!() == governance)
        
        if (add) {
            let b = PairInfo {
                pair: pair,
                decimals: decimals,
                oracle: oracle
            }

            tokenPairs.insert!(callerAddress!(), token, b)
        }

        else {
            tokenPairs.remove!(callerAddress!(), token)
        }
    }
}