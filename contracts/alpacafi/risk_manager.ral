// RiskManager.ral

struct TokenRiskParams {
    // All in basis points (10000 = 100%)
    mut borrowingEnabled: Bool,      // Whether borrowing is enabled
    mut collateralFactor: U256,      // Max percentage of collateral value that can be borrowed (e.g., 7500 = 75%)
    mut liquidationThreshold: U256,  // Percentage at which position can be liquidated (e.g., 8250 = 82.5%)
    mut liquidationPenalty: U256,    // Penalty added during liquidation (e.g., 500 = 5%)
    mut borrowCap: U256,             // Maximum amount that can be borrowed from the protocol
    mut supplyCap: U256,             // Maximum amount that can be supplied to the protocol
    mut reserveFactor: U256          // Percentage of interest that goes to reserves (e.g., 1000 = 10%)
}

Contract RiskManager (
    registry: Address,
    oracle: Address,     // Main price oracle address
    testOracle: Address, // Test oracle address for development
    mut governance: Address
) {
    // Token ID => Risk Parameters
    mapping[ByteVec, TokenRiskParams] tokenRiskParams
    
    // Flattened collateral pair eligibility mappings
    // Key format: collateralToken + borrowToken => Bool
    mapping[ByteVec, Bool] collateralPairEligibility
    
    // Token => Oracle pair configuration
    mapping[ByteVec, PairInfo] tokenPairs
    
    // Events
    event RiskParamsUpdated(token: ByteVec, collateralFactor: U256, liquidationThreshold: U256)
    event CollateralPairUpdated(collateralToken: ByteVec, borrowToken: ByteVec, eligible: Bool)
    event OraclePairUpdated(token: ByteVec, pair: ByteVec, decimals: U256, useMainOracle: Bool)
    
    // Helper function to create compound key
    fn createPairKey(collateralToken: ByteVec, borrowToken: ByteVec) -> ByteVec {
        return encodeToByteVec!(collateralToken, borrowToken)
    }
    
    // Default risk parameters
    fn getDefaultRiskParams() -> TokenRiskParams {
        return TokenRiskParams {
            borrowingEnabled: false,
            collateralFactor: 7500,     // 75%
            liquidationThreshold: 8250, // 82.5%
            liquidationPenalty: 500,    // 5%
            borrowCap: 1000000000000000000000000000, // 1 billion tokens
            supplyCap: 1000000000000000000000000000, // 1 billion tokens
            reserveFactor: 1000         // 10%
        }
    }
    
    pub fn getTokenRiskParams(token: ByteVec) -> TokenRiskParams {
        if (tokenRiskParams.contains!(token)) {
            return tokenRiskParams[token]
        }
        
        return getDefaultRiskParams()
    }
    
    pub fn canUseAsCollateral(collateralToken: ByteVec, borrowToken: ByteVec) -> Bool {
        let pairKey = createPairKey(collateralToken, borrowToken)
        
        if (collateralPairEligibility.contains!(pairKey)) {
            return collateralPairEligibility[pairKey]
        }
        
        return false // By default, pairs are not eligible
    }
    
    // Get token price from oracle with fallback
    pub fn getTokenPrice(token: ByteVec) -> U256 {
        if (!tokenPairs.contains!(token)) {
            return 0 // Token not configured
        }
        
        let pairInfo = tokenPairs[token]
        
        if (pairInfo.oracle) {
            // Use main oracle
            let priceOracle = AlpacaFiOracle(addressToContractId!(oracle))
            let oracleData = priceOracle.getValue(pairInfo.pair)
            return oracleData.value
        } else {
            // Use test oracle for development
            let priceOracle = AlpacaFiOracle(addressToContractId!(testOracle))
            let oracleData = priceOracle.getValue(pairInfo.pair)
            return oracleData.value
        }
    }
    
    // Modified to work with the MultiDebt implementation and oracle integration
    pub fn checkHealthFactor(debtId: U256) -> (U256, Bool) {
        let reg = Registry(addressToContractId!(registry))
        let debtManager = DebtManager(addressToContractId!(reg.getDebtManager()))
        
        // Get the debt position
        let debtPosition = debtManager.getDebtPosition(debtId)
        let debt = MultiDebt(subContractId!(debtPosition.contractId))
        
        let mut totalBorrowValueInUSD = 0
        let mut totalCollateralValueInUSD = 0
        
        // Calculate total borrow value by iterating through all borrow positions
        let borrowCount = debt.getBorrowPositionsCount()
        let mut i = 0
        
        while (i < borrowCount) {
            let token = debt.getBorrowTokenAtIndex(i)
            let (exists, position) = debt.getBorrowPosition(token)
            
            if (exists) {
                let totalDebtForToken = debt.calculateRepayment(token)
                let tokenPrice = getTokenPrice(token)
                
                if (tokenPrice > 0) {
                    // Convert to USD value (assuming price is in USD with 8 decimals)
                    let borrowValueInUSD = (totalDebtForToken * tokenPrice) / (10 |**| 8)
                    totalBorrowValueInUSD = totalBorrowValueInUSD + borrowValueInUSD
                }
            }
            
            i = i + 1
        }
        
        // Calculate total collateral value by iterating through all collateral positions
        let collateralCount = debt.getCollateralPositionsCount()
        let mut j = 0
        
        while (j < collateralCount) {
            let token = debt.getCollateralTokenAtIndex(j)
            let (exists, position) = debt.getCollateralPosition(token)
            
            if (exists) {
                let tokenPrice = getTokenPrice(token)
                
                if (tokenPrice > 0) {
                    let riskParams = getTokenRiskParams(token)
                    
                    // Convert to USD value and apply collateral factor
                    let collateralValueInUSD = (position.amount * tokenPrice) / (10 |**| 8)
                    let adjustedCollateralValue = (collateralValueInUSD * riskParams.collateralFactor) / 10000
                    
                    totalCollateralValueInUSD = totalCollateralValueInUSD + adjustedCollateralValue
                }
            }
            
            j = j + 1
        }
        
        // Calculate health factor (scaled by 10000 for precision)
        let mut healthFactor = 0
        if (totalBorrowValueInUSD > 0) {
            healthFactor = (totalCollateralValueInUSD * 10000) / totalBorrowValueInUSD
        } else {
            healthFactor = 100000 // Max health if no borrows
        }
        
        // Health factor below 1.0 (10000) means undercollateralized
        return healthFactor, healthFactor >= 10000
    }
    
    @using(checkExternalCaller = true, updateFields = true, assetsInContract = true)
    pub fn setTokenRiskParams(
        token: ByteVec,
        borrowingEnabled: Bool,
        collateralFactor: U256,
        liquidationThreshold: U256,
        liquidationPenalty: U256,
        borrowCap: U256,
        supplyCap: U256,
        reserveFactor: U256
    ) -> () {
        checkCaller!(callerAddress!() == governance, 1)
        
        // Validate parameters
        assert!(collateralFactor <= 9000, 2) // Max 90% collateral factor
        assert!(liquidationThreshold > collateralFactor, 3) // Must have a buffer
        assert!(liquidationThreshold <= 9500, 4) // Max 95% liquidation threshold
        assert!(liquidationPenalty <= 2000, 5) // Max 20% liquidation penalty
        assert!(reserveFactor <= 5000, 6) // Max 50% reserve factor
        
        let params = TokenRiskParams {
            borrowingEnabled: borrowingEnabled,
            collateralFactor: collateralFactor,
            liquidationThreshold: liquidationThreshold,
            liquidationPenalty: liquidationPenalty,
            borrowCap: borrowCap,
            supplyCap: supplyCap,
            reserveFactor: reserveFactor
        }
        
        // Check if entry exists, otherwise create it
        if (tokenRiskParams.contains!(token)) {
            tokenRiskParams[token] = params
        } else {
            tokenRiskParams.insert!(governance, token, params)
        }
        
        emit RiskParamsUpdated(token, collateralFactor, liquidationThreshold)
    }
    
    @using(checkExternalCaller = true, updateFields = true, assetsInContract = true)
    pub fn setCollateralPair(
        collateralToken: ByteVec, 
        borrowToken: ByteVec, 
        eligible: Bool
    ) -> () {
        checkCaller!(callerAddress!() == governance, 1)
        
        // Create compound key for the pair
        let pairKey = createPairKey(collateralToken, borrowToken)
        
        // Check if entry exists, otherwise create it
        if (collateralPairEligibility.contains!(pairKey)) {
            collateralPairEligibility[pairKey] = eligible
        } else {
            collateralPairEligibility.insert!(governance, pairKey, eligible)
        }
        
        emit CollateralPairUpdated(collateralToken, borrowToken, eligible)
    }
    
    @using(checkExternalCaller = true, updateFields = true)
    pub fn updateGovernance(newGovernance: Address) -> () {
        checkCaller!(callerAddress!() == governance, 1)
        governance = newGovernance
    }
    
    @using(checkExternalCaller = true, assetsInContract = true)
    pub fn prepareForTokens(numTokens: U256, numPairs: U256) -> () {
        checkCaller!(callerAddress!() == governance, 7)
        
        // Calculate total entries needed
        let totalEntries = numTokens * 2 + numPairs // Risk params + oracle pairs + collateral pairs
        let deposit = mapEntryDeposit!() * totalEntries
    }

    // Oracle configuration for tokens
    @using(checkExternalCaller = true, assetsInContract = true)
    pub fn setTokenOraclePair(token: ByteVec, pair: ByteVec, decimals: U256, useMainOracle: Bool) -> () {
        checkCaller!(callerAddress!() == governance, 9)
        
        let pairInfo = PairInfo {
            pair: pair,
            decimals: decimals,
            oracle: useMainOracle
        }
        
        // Check if entry exists, otherwise create it
        if (tokenPairs.contains!(token)) {
            tokenPairs[token] = pairInfo
        } else {
            tokenPairs.insert!(governance, token, pairInfo)
        }
        
        emit OraclePairUpdated(token, pair, decimals, useMainOracle)
    }
}