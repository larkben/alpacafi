Contract LendingPoolFactory (
    admin: Address,
    lendingPoolTemplate: ByteVec,
    mut lendingHelper: ByteVec,
    // nft | account
    accountTemplate: ByteVec,
    tokenTemplate: ByteVec,
    mut numAccounts: U256
) {
    
    // MAPPING
    mapping [ByteVec, PairInfo] tokens

    // -------------------
    // EVENTS
    // -------------------

    event AccountCreated(who: Address, nft: ByteVec, number: U256)

    event PoolCreated(tokenLend: ByteVec, tokenCollateral: ByteVec, time: U256)

    event Borrow()
    event Lend()

    event Liquidate()
    event Bid()
    event Hammer()

    event Repay()
    event Claim()

    // -------------------
    // MAPPING | CONFIG
    // -------------------
    
    @using(checkExternalCaller = true, preapprovedAssets = true)
    pub fn mappingConfig(token: ByteVec, pair: ByteVec, decimals: U256, dia: Bool, add: Bool) -> () {
        checkCaller!(callerAddress!() == admin, 0)

        let temp = PairInfo {
            pair: pair,
            decimals: decimals,
            oracle: dia
        }

        if (add) {
            tokens.insert!(callerAddress!(), token, temp)
        }
        else {
            tokens.remove!(callerAddress!(), token)
        }
    }

    @using(checkExternalCaller = true, updateFields =  true)
    pub fn editLendingHelper(newHelper: ByteVec) -> () {
        checkCaller!(callerAddress!() == admin, 0)

        lendingHelper = newHelper
    }

    // -------------------
    // GET METHODS
    // -------------------

    pub fn getMapping(tokenId: ByteVec) -> (Bool, PairInfo) {
        if (tokens.contains!(tokenId)) {
            return true, tokens[tokenId]
        }
        else {
            let temp = PairInfo {
                pair: b``,
                decimals: 0,
                oracle: false
            }

            return false, temp
        }
    }

    pub fn getSubPool(tokenLend: ByteVec, tokenCollateral: ByteVec) -> (ByteVec) {

        //? path formula: lend ++ collateral

        return subContractId!(tokenLend ++ tokenCollateral)
    }

    pub fn collateralNeeded(lToken: ByteVec, dToken: ByteVec, desired: U256) -> (U256, Bool) {

        return LendingHelper(lendingHelper).determineCollateralAmountWithMapping(
            lToken,
            desired,
            dToken,
            15000       // 150% ratio
        )
        
    }

    // -------------------
    // METHODS
    // -------------------

    pub fn create(tokenLend: ByteVec, tokenCollateral: ByteVec) -> () {

        // admin only
        let caller = callerAddress!()
        checkCaller!(caller == admin, 0)

        // create pool fields
        let (encodeImmutableFields, encodeMutableFields) = LendingPool.encodeFields!(
            selfContractId!(),
            tokenLend,
            tokenCollateral,
            0,
            0,
            0,
            0,
            blockTimeStamp!(),
            0
        )

        let poolID = copyCreateSubContract!{caller -> ALPH: minimalContractDeposit!()}(
            tokenLend ++ tokenCollateral,
            lendingPoolTemplate,                                                                                  
            encodeImmutableFields,
            encodeMutableFields
        )

        // emit
        emit PoolCreated (
            tokenLend, 
            tokenCollateral,
            blockTimeStamp!()
        )
        
    }

    @using(checkExternalCaller = false, updateFields = true)
    pub fn createAccount(tokenUri: ByteVec) -> () {

        let caller = callerAddress!()

        let (encodeImmutableFields, encodeMutableFields) = Account.encodeFields!(
            tokenUri,
            selfContractId!(),
            numAccounts,
            selfContractId!(),
            tokenTemplate
        )

        let nftID = copyCreateSubContract!{caller -> ALPH: minimalContractDeposit!()}(
            toByteVec!(numAccounts),
            accountTemplate,                                                                                  
            encodeImmutableFields,
            encodeMutableFields
        )

        numAccounts = numAccounts + 1

        emit AccountCreated (caller, nftID, numAccounts)
    }

    // borrow
    pub fn borrow(nft: ByteVec, desired: ByteVec, amount: U256, collateral: ByteVec, cAmount: U256) -> () {

        let caller = callerAddress!()
        let path = desired ++ collateral

        let poolId = subContractId!(path)

        checkCaller!(caller == contractIdToAddress!(poolId), 0)

        emit Borrow()
    }

    // lend
    pub fn lend(nft: ByteVec) -> () {
        // calls the nft

        // takes funds from nft

        // creates mapping to represent interest / stake

        emit Lend()
    }

    // liquidate
    pub fn liquidate() -> () {
        // checks the user token position, if undercollateralized user position goes up for auction

        // emit

        emit Liquidate()
    }

    // bid
    pub fn bid() -> () {
        // emit

        emit Bid()
    }

    // hammer `auction end`
    pub fn hammer() -> () {
        // emit

        emit Hammer()
    }

    // repay loan
    pub fn repay() -> () {
        // emit

        emit Repay()
    }

    // claim
    pub fn claim() -> () {
        // emit

        emit Claim()
    }
}