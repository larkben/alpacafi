Contract LendingPoolFactory (
    admin: Address,
    lendingPoolTemplate: ByteVec,
    mut lendingHelper: ByteVec,
    // nft | account
    accountTemplate: ByteVec,
    tokenTemplate: ByteVec,
    mut numAccounts: U256
) {

    mapping [ByteVec, PairInfo] tokens

    event AccountCreated(who: Address, nft: ByteVec, number: U256)

    // mapping config
    @using(checkExternalCaller = true, preapprovedAssets = true)
    pub fn mappingConfig(token: ByteVec, pair: ByteVec, decimals: U256, dia: Bool, add: Bool) -> () {
        checkCaller!(callerAddress!() == admin, 0)

        let temp = PairInfo {
            pair: pair,
            decimals: decimals,
            oracle: dia
        }

        if (add) {
            tokens.insert!(callerAddress!(), token, temp)
        }
        else {
            tokens.remove!(callerAddress!(), token)
        }
    }

    // get mapping value
    pub fn getMapping(tokenId: ByteVec) -> (Bool, PairInfo) {
        if (tokens.contains!(tokenId)) {
            return true, tokens[tokenId]
        }
        else {
            let temp = PairInfo {
                pair: b``,
                decimals: 0,
                oracle: false
            }

            return false, temp
        }
    }

    // config function
    @using(checkExternalCaller = true, updateFields =  true)
    pub fn editLendingHelper(newHelper: ByteVec) -> () {
        checkCaller!(callerAddress!() == admin, 0)

        lendingHelper = newHelper
    }

    // get sub pools
    pub fn getSubPool(tokenLend: ByteVec, tokenCollateral: ByteVec) -> (ByteVec) {

        //? path formula: lend ++ collateral

        return subContractId!(tokenLend ++ tokenCollateral)
    }

    pub fn getRatio(path: ByteVec) -> () {
        return LendingPool(subContractId!(path)).getRatio()
    }

    pub fn collateralNeeded(token: ByteVec, desired: U256) -> (U256) {

        let coin = tokens[token]

        return LendingHelper(lendingHelper).determineCollateralAmount(
            coin.pair,
            coin.decimals,
            desired,
            15000                                                // 150% collateral ratio
        )
    }

    // create pool
    pub fn create(tokenLend: ByteVec, tokenCollateral: ByteVec) -> () {
        // admin only
        let caller = callerAddress!()
        checkCaller!(caller == admin, 0)

        // create pool fields
        let (encodeImmutableFields, encodeMutableFields) = LendingPool.encodeFields!(
            selfContractId!(),
            tokenLend,                          
            tokenCollateral,                    
            0,
            0,
            0,
            0,
            blockTimeStamp!(),
            0
        )

        let poolID = copyCreateSubContract!{caller -> ALPH: minimalContractDeposit!()}(
            tokenLend ++ tokenCollateral,
            lendingPoolTemplate,                                                                                  
            encodeImmutableFields,
            encodeMutableFields
        )

        // emit
    }

    // create account
    @using(checkExternalCaller = false, updateFields = true)
    pub fn createAccount(tokenUri: ByteVec) -> () {

        let caller = callerAddress!()

        let (encodeImmutableFields, encodeMutableFields) = Account.encodeFields!(
            tokenUri,
            selfContractId!(),
            numAccounts,
            selfContractId!(),
            tokenTemplate
        )

        let nftID = copyCreateSubContract!{caller -> ALPH: minimalContractDeposit!()}(
            toByteVec!(numAccounts),
            accountTemplate,                                                                                  
            encodeImmutableFields,
            encodeMutableFields
        )

        numAccounts = numAccounts + 1

        emit AccountCreated (caller, nftID, numAccounts)
    }

    // borrow
    pub fn borrow() -> () {
        // calls the nft

        // funds sent to caller

        // funds subtracted from nft
    }

    // lend
    pub fn lend() -> () {
        // calls the nft

        // takes funds from nft

        // creates mapping to represent interest / stake
    }

    // liquidate
    pub fn liquidate() -> () {
        // checks the user token position, if undercollateralized user position goes up for auction
    }
}