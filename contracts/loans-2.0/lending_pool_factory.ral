Contract LendingPoolFactory (
    admin: Address,
    lendingPoolTemplate: ByteVec,
    // nft | account
    accountTemplate: ByteVec,
    tokenTemplate: ByteVec,
    mut numAccounts: U256
) {

    event AccountCreated(who: Address, nft: ByteVec, number: U256)

    // create pool
    pub fn create() -> () {
        // admin only
        
    }

    // create account
    @using(checkExternalCaller = false, updateFields = true)
    pub fn createAccount(tokenUri: ByteVec) -> () {

        let caller = callerAddress!()

        let (encodeImmutableFields, encodeMutableFields) = Account.encodeFields!(
            tokenUri,
            selfContractId!(),
            numAccounts,
            tokenTemplate
        )

        let nftID = copyCreateContract!{caller -> ALPH: minimalContractDeposit!()}(
            accountTemplate,                                                                                  
            encodeImmutableFields,
            encodeMutableFields
        )

        numAccounts = numAccounts + 1

        emit AccountCreated (caller, nftID, numAccounts)
    }

    // borrow
    pub fn borrow() -> () {
        // calls the nft

        // funds sent to caller

        // funds subtracted from nft
    }

    // lend
    pub fn lend() -> () {
        // calls the nft

        // takes funds from nft

        // creates mapping to represent interest / stake
    }

    // liquidate
    pub fn liquidate() -> () {
        // checks the user token position, if undercollateralized user position goes up for auction
    }
}