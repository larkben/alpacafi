// storage for tokens

Contract TokenTemplate (
    nft: ByteVec,
    token: ByteVec,
    mut amount: U256,
    // lended out
    mut lent: U256,
    mut borrowed: U256
) {
    // withdraw
    @using(checkExternalCaller = true, updateFields = true, preapprovedAssets = false, assetsInContract = true)
    pub fn withdraw(caller: Address, size: U256) -> () {

        // verify it was called from nft
        checkCaller!(callerAddress!() == contractIdToAddress!(nft), 0)
        
        // confirm this is available and it's not lended or loaned out
        assert!(size <= amount, 0)
        
        transferToken!(selfAddress!(), caller, token, size)

        amount = amount - size
    }

    // deposit
    @using(checkExternalCaller = true, updateFields = true, preapprovedAssets = true)
    pub fn deposit(caller: Address, size: U256) -> () {

        checkCaller!(callerAddress!() == contractIdToAddress!(nft), 0)

        transferToken!(caller, selfAddress!(), token, size)

        amount = amount + size
    }

    // borrow against
    pub fn borrow(poolf: ByteVec, pool: ByteVec, desired: ByteVec, want: U256) -> () {

        // perform required collateral checks
        let (required, valid) = LendingPoolFactory(poolf).collateralNeeded(
            desired, 
            token, 
            want
        )

        // verify is valid
        assert!(valid == true, 0)

        // verify they have enough token to post collateral and update token amount
        assert!(amount >= required, 0)
        amount = amount - required  

        // call the function for borrow from lending pool
        LendingPool(pool).borrow(nft, selfAddress!(), want)
    }

    // lend out
    pub fn lend(size: U256) -> () {
        lent = lent + size
    }

    pub fn claimRewards(size: U256) -> () {

    }
}