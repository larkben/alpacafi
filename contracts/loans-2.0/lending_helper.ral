Contract LendingHelper (
    // oracle: IDIAOracle,  // DIA oracle
    lendingFactory: ByteVec,
    oracle: ByteVec,            
    alpaca: ByteVec         // custom oracle
) {
    // determine collateral ratio
    pub fn determineCollateralRatio(
        tokenRequested: ByteVec,
        tokenAmount: U256,
        collateralToken: ByteVec, 
        collateralAmount: U256,
        threshhold: U256
    ) -> (U256, Bool) {
        
        let (isValid, pair) = LendingPoolFactory(lendingFactory).getMapping(tokenRequested)
        let (isValidTwo, pairTwo) = LendingPoolFactory(lendingFactory).getMapping(collateralToken)

        if (isValid == true && isValidTwo == true) {
            let mut loanValue = 0
            let mut collateralValue = 0

            // fetch token price
            if (pair.oracle) {
                loanValue = TestOracle(oracle).getValue(pair.pair).value
            }
            else {
                loanValue = AlpacaFiOracle(alpaca).getValue(pair.pair).value
            }

            // fetch collateral price
            if (pairTwo.oracle) {
                collateralValue = TestOracle(oracle).getValue(pairTwo.pair).value
            }
            else {
                collateralValue = AlpacaFiOracle(alpaca).getValue(pairTwo.pair).value
            }

            if (loanValue == 0 || collateralValue == 0) {
                return 0, false
            }

            let collateralDecimals = pairTwo.decimals
            let tokenDecimals = pair.decimals

            // Normalize collateral amount to 18 decimals
            let collateralNormalized = (collateralAmount * (10 |**| 18)) / (10 |**| collateralDecimals)
            let collateralValueUSD = (collateralNormalized * collateralValue) / (10 |**| 8) // Remove 8 decimals

            // Normalize loan amount to 18 decimals
            let loanNormalized = (tokenAmount * (10 |**| 18)) / (10 |**| tokenDecimals)
            let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8) // Remove 8 decimals

            // Compute collateral-to-loan ratio in basis points (10000 = 100%)
            let ratio = (collateralValueUSD * 10000) / loanValueUSD // Multiply before division to avoid precision loss

            if (ratio > threshhold) {
                return ratio, true
            }

            else {
                return ratio, false
            }
        }

        return 0, false
    }

    // Convenience function that uses the lending factory's token mappings
    @using(checkExternalCaller = false)
    pub fn determineCollateralAmountWithMapping(
        loanToken: ByteVec,            // Token ID for the loan
        loanAmount: U256,              // Amount to borrow
        collateralToken: ByteVec,      // Token ID for collateral
        desiredRatio: U256             // Desired collateral ratio in basis points
    ) -> (U256, Bool) {
        
        // Get mapping info for both tokens from the lending factory
        let (isValidLoan, loanPair) = LendingPoolFactory(lendingFactory).getMapping(loanToken)
        let (isValidCollateral, collateralPair) = LendingPoolFactory(lendingFactory).getMapping(collateralToken)
        
        // Check if both tokens are supported
        if (!isValidLoan || !isValidCollateral) {
            return 0, false
        }
        
        // Determine which oracle to use for each token
        let mut loanValue = 0
        let mut collateralValue = 0
        
        if (loanPair.oracle) {
            loanValue = TestOracle(oracle).getValue(loanPair.pair).value
        } else {
            loanValue = AlpacaFiOracle(alpaca).getValue(loanPair.pair).value
        }
        
        if (collateralPair.oracle) {
            collateralValue = TestOracle(oracle).getValue(collateralPair.pair).value
        } else {
            collateralValue = AlpacaFiOracle(alpaca).getValue(collateralPair.pair).value
        }
        
        // Safety checks
        if (loanValue == 0 || collateralValue == 0 || desiredRatio == 0) {
            return 0, false
        }
        
        // Use the token decimals from the mapping
        let loanDecimals = loanPair.decimals
        let collateralDecimals = collateralPair.decimals
        
        // Normalize loan amount to 18 decimals
        let loanNormalized = (loanAmount * (10 |**| 18)) / (10 |**| loanDecimals)
        
        // Calculate loan value in USD
        let loanValueUSD = (loanNormalized * loanValue) / (10 |**| 8)
        
        // Calculate required collateral value in USD
        let requiredCollateralUSD = (loanValueUSD * desiredRatio) / 10000
        
        // Convert to collateral token amount
        let collateralNormalized = (requiredCollateralUSD * (10 |**| 8)) / collateralValue
        let requiredCollateralAmount = (collateralNormalized * (10 |**| collateralDecimals)) / (10 |**| 18)
        
        return requiredCollateralAmount, true
    }

}