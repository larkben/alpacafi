import "std/nft_interface"

// NFT to represent loan account (lender and borrower)

Contract Account(
    tokenUri: ByteVec,
    collectionId: ByteVec,
    nftIndex: U256,
    // token storage
    lendingFactoryPool: ByteVec,
    tokenTemplate: ByteVec
)implements INFT {

  // --------------------
  // INFT METHODS
  // --------------------

  pub fn getTokenUri() -> ByteVec {
    return tokenUri
  }

  pub fn getNFTIndex() -> U256 {
    return nftIndex
  }

  pub fn getCollectionIndex() -> (ByteVec, U256) {
    return collectionId, nftIndex
  }

  // --------------------
  // GET METHODS
  // --------------------

  // --------------------
  // METHODS
  // --------------------

  fn doesExist(token: ByteVec) -> Bool {
    let id = subContractId!(token)

    return contractExists!(id)
  }

  pub fn depositToken(token: ByteVec, amount: U256) -> () {

    let caller = callerAddress!()

    // aps / verify
    transferToken!(caller, caller, selfTokenId!(), 1)

    // if the storage mapping doesn't already exist
    if (doesExist(token)) {

      let (encodeImmutableFields, encodeMutableFields) = TokenTemplate.encodeFields!(
        selfTokenId!(),
        token,
        amount,
        0,
        0
      )

      let nftID = copyCreateSubContract!{caller -> ALPH: minimalContractDeposit!(), token: amount}(
        token,
        tokenTemplate,                                                                                  
        encodeImmutableFields,
        encodeMutableFields
      )
    }

    // call the storage mapping and add the token to it
    else {
      let id = subContractId!(token)

      let storage = TokenTemplate(id)

      storage.deposit{caller -> token: amount}(caller, amount)
    }
  }

  pub fn withdraw(token: ByteVec, amount: U256) -> () {
    let caller = callerAddress!()

    // aps / verify
    transferToken!(caller, caller, selfTokenId!(), 1)

    assert!(doesExist(token) == true, 0) // token contract does not exist

    // perform the withdraw
    let id = subContractId!(token)

    let storage = TokenTemplate(id)

    storage.withdraw(caller, amount)
  }

  // borrow against a held token
  pub fn borrow(desired: ByteVec, desiredAmount: U256, collateral: ByteVec) -> () {
    let caller = callerAddress!()

    // aps / verify
    transferToken!(caller, caller, selfTokenId!(), 1)

    assert!(doesExist(collateral) == true, 0) // token contract does not exist

    // borrow against the token
    let id = subContractId!(collateral)

    let storage = TokenTemplate(id)

    // call the borrow function on the asset storage contract
    storage.borrow(lendingFactoryPool, desired ++ collateral, desired, desiredAmount)
  }
}