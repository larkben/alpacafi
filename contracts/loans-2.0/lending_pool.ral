Contract LendingPool (
    poolFactory: LendingPoolFactory,
    lendToken: ByteVec,                 // renamed for clarity
    collateralToken: ByteVec,           // added collateral token
    mut feesGenerated: U256,
    mut amountToLend: U256,
    mut totalLended: U256,
    mut totalDebtAmount: U256,          // added missing field
    mut lastUpdateTime: U256,
    mut poolRatio: U256                 // ratio required 
) {
    mapping [ByteVec, LendPosition] lendPositions
    mapping [ByteVec, DebtPosition] debtPositions

    // periodically every 8 hours debts will pay lenders
    event LendPositionCreated(lender: ByteVec, amount: U256)
    event DebtPositionCreated(borrower: ByteVec, amount: U256)
    event FeesCollected(totalFees: U256, timestamp: U256)
    event LendPositionClosed(lender: ByteVec, amount: U256)
    event DebtPositionClosed(borrower: ByteVec, amount: U256)
    event FundingRateCollected(amount: U256, timestamp: U256)
    
    // 8 hours in milliseconds
    const FEE_COLLECTION_INTERVAL = 28800000

    // 0.1% fee (1/1000) - this is the base rate per 8 hours
    const FEE_RATE_NUMERATOR = 1
    const FEE_RATE_DENOMINATOR = 1000
    
    // Minimum decimals for calculations
    const MIN_DECIMALS = 6

    pub fn getRatio() -> (U256) {
        return poolRatio
    }

    // Calculate and collect funding rate based on time elapsed
    @using(updateFields = true)
    fn collectFundingRate() -> () {
        let currentTime = blockTimeStamp!()
        
        // Skip if no debt to charge fees on
        if (totalDebtAmount == 0) {
            return
        }
        
        // Calculate time elapsed since last update
        let timeElapsed = currentTime - lastUpdateTime
        
        // Skip if no time has passed
        if (timeElapsed == 0) {
            return
        }
        
        // Calculate funding rate proportional to time elapsed
        // Formula: (debtAmount * feeRate * timeElapsed) / (FEE_COLLECTION_INTERVAL * denominator)
        let fundingFee = (totalDebtAmount * FEE_RATE_NUMERATOR * timeElapsed) / (FEE_COLLECTION_INTERVAL * FEE_RATE_DENOMINATOR)
        
        // Only collect if fee is meaningful (at least 1 unit with min decimals)
        let minFee = 10 |**| MIN_DECIMALS
        if (fundingFee >= minFee) {
            feesGenerated = feesGenerated + fundingFee
            emit FundingRateCollected(fundingFee, currentTime)
        }
        
        // Update last collection time
        lastUpdateTime = currentTime
    }
    
    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true)
    pub fn lend(account: ByteVec, user: Address, caller: Address, amount: U256) -> () {
        assert!(amount > 0, ErrorCodes.InvalidAmount)
        
        // Collect funding rate before state changes
        //! total debt * 0.01% funding rate every 8 hours and should be calculated every time function it called proprtional
        //! to how much of the 8 hours has passed, should take totalDebt * (timepassed * 0.1%) and add to fees accrued
        collectFundingRate()
        
        // Transfer tokens to contract from caller
        transferTokenToSelf!(caller, lendToken, amount)
        
        // Update or create lend position
        if (lendPositions.contains!(account)) {
            let mut position = lendPositions[account]
            position.lendedAmount = position.lendedAmount + amount
            lendPositions[account] = position
        } else {
            let temp = LendPosition {
                contract: selfAddress!(),
                lendedAmount: amount,
                timeEntered: blockTimeStamp!()
            }

            //! mapping needs to be posted from user
            lendPositions.insert!(user, account)
        }
        
        // Update global state
        amountToLend = amountToLend + amount
        totalLended = totalLended + amount
        
        emit LendPositionCreated(caller, amount)
    }
    
    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true)
    pub fn borrow(account: ByteVec, caller: Address, amount: U256) -> () {
        assert!(amount > 0, ErrorCodes.InvalidAmount)
        assert!(amount <= amountToLend, ErrorCodes.InsufficientLiquidity)
        
        // collect funding rate before state changes
        collectFundingRate()
        
        let caller = callerAddress!()

        // validate collateral needed
        let (collateralAmount, valid) = LendingPoolFactory(poolFactory).collateralNeeded(
            lendToken,
            amount,
            collateralToken,
            15000               // 150%
        )

        // collect collateral
        transferToken!(caller, selfAddress!(), collateralToken, collateralAmount)
        
        // Update or create debt position
        if (debtPositions.contains!(account)) {
            let mut position = debtPositions[account]
            position.debtAmount = position.debtAmount + amount
            debtPositions[account] = position
        } else {
            debtPositions[account] = DebtPosition {
                contract: selfAddress!(),
                debtAmount: amount,
                timeEntered: blockTimeStamp!()
            }
        }
        
        // update global state
        amountToLend = amountToLend - amount
        totalDebtAmount = totalDebtAmount + amount
        
        // Transfer tokens to borrower
        transferTokenFromSelf!(caller, lendToken, amount)
        
        emit DebtPositionCreated(caller, amount)
    }
    
    //! need to work on this
    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true)
    pub fn repayDebt(account: ByteVec, caller: Address, amount: U256) -> () {
        assert!(amount > 0, ErrorCodes.InvalidAmount)
        
        // Collect funding rate before state changes
        collectFundingRate()
        
        let caller = callerAddress!()
        assert!(debtPositions.contains!(caller), ErrorCodes.NoDebtPosition)
        
        let mut position = debtPositions[caller]
        assert!(amount <= position.debtAmount, ErrorCodes.ExcessiveRepayment)
        
        // Transfer repayment to contract
        transferTokenToSelf!(caller, lendToken, amount)
        
        // Update debt position
        position.debtAmount = position.debtAmount - amount
        if (position.debtAmount == 0) {
            debtPositions.remove!(caller)
        } else {
            debtPositions[caller] = position
        }
        
        // Update global state
        amountToLend = amountToLend + amount
        totalDebtAmount = totalDebtAmount - amount
        
        emit DebtPositionClosed(caller, amount)
    }
    
    //! need to work on this
    //? this should allow the user to withdraw rewards from current lend token ratio 
    //?     relative to rewards earned from funding rate and protocol fees
    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true)
    pub fn withdrawLend(account: ByteVec, caller: Address, amount: U256) -> () {
        assert!(amount > 0, ErrorCodes.InvalidAmount)
        
        // Collect funding rate before state changes
        collectFundingRate()
        
        let caller = callerAddress!()
        assert!(lendPositions.contains!(caller), ErrorCodes.NoLendPosition)
        
        let mut position = lendPositions[caller]
        assert!(amount <= position.lendedAmount, ErrorCodes.InsufficientLendPosition)
        assert!(amount <= amountToLend, ErrorCodes.InsufficientLiquidity)
        
        // Update lend position
        position.lendedAmount = position.lendedAmount - amount
        if (position.lendedAmount == 0) {
            lendPositions.remove!(caller)
        } else {
            lendPositions[caller] = position
        }
        
        // Update global state
        amountToLend = amountToLend - amount
        totalLended = totalLended - amount
        
        // Transfer tokens back to lender
        transferTokenFromSelf!(caller, lendToken, amount)
        
        emit LendPositionClosed(caller, amount)
    }

    // Public function to manually trigger funding rate collection
    // ? this is fine -> possibly pointless but fine
    @using(updateFields = true)
    pub fn triggerFundingRateCollection() -> () {
        collectFundingRate()
    }

    // View function to calculate pending funding fees without collecting
    //? prenotion to fees about to be accrued
    pub fn getPendingFundingFees() -> U256 {
        if (totalDebtAmount == 0) {
            return 0
        }
        
        let currentTime = blockTimeStamp!()
        let timeElapsed = currentTime - lastUpdateTime
        
        if (timeElapsed == 0) {
            return 0
        }
        
        return (totalDebtAmount * FEE_RATE_NUMERATOR * timeElapsed) / (FEE_COLLECTION_INTERVAL * FEE_RATE_DENOMINATOR)
    }

    // View function to get pool info
    pub fn getPoolInfo() -> (ByteVec, ByteVec, U256, U256, U256, U256, U256) {
        return (lendToken, collateralToken, feesGenerated, amountToLend, totalLended, totalDebtAmount, lastUpdateTime)
    }
}